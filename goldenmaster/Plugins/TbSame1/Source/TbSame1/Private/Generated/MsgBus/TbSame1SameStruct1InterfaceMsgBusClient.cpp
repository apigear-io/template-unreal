/**
Copyright 2021 ApiGear UG
Copyright 2021 Epic Games, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

////////////////////////////////
// WARNING AUTOGENERATED
// DO NOT MODIFY
///////////////////////////////

#include "Generated/MsgBus/TbSame1SameStruct1InterfaceMsgBusClient.h"
#include "Generated/MsgBus/TbSame1SameStruct1InterfaceMsgBusMessages.h"
#include "Async/Async.h"
#include "Engine/Engine.h"
#include "Misc/DateTime.h"
#include "MessageEndpointBuilder.h"
#include "MessageEndpoint.h"
#include "HAL/CriticalSection.h"

/**
   \brief data structure to hold the last sent property values
*/
struct TbSame1SameStruct1InterfacePropertiesMsgBusData
{
	FCriticalSection Prop1Mutex;
	FTbSame1Struct1 Prop1{FTbSame1Struct1()};
};
DEFINE_LOG_CATEGORY(LogTbSame1SameStruct1InterfaceMsgBusClient);

UTbSame1SameStruct1InterfaceMsgBusClient::UTbSame1SameStruct1InterfaceMsgBusClient()
	: UAbstractTbSame1SameStruct1Interface()
	, _SentData(MakePimpl<TbSame1SameStruct1InterfacePropertiesMsgBusData>())
{
	/* m_sink = std::make_shared<FOLinkSink>("tb.same1.SameStruct1Interface"); */
}

UTbSame1SameStruct1InterfaceMsgBusClient::~UTbSame1SameStruct1InterfaceMsgBusClient() = default;

void UTbSame1SameStruct1InterfaceMsgBusClient::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);

	Connect();
}

void UTbSame1SameStruct1InterfaceMsgBusClient::Deinitialize()
{
	Disconnect();

	Super::Deinitialize();
}

void UTbSame1SameStruct1InterfaceMsgBusClient::Connect()
{
	if (IsConnected())
	{
		return;
	}

	if (TbSame1SameStruct1InterfaceMsgBusEndpoint.IsValid() && !ServiceAddress.IsValid())
	{
		DiscoverService();
		return;
	}

	// clang-format off
	TbSame1SameStruct1InterfaceMsgBusEndpoint = FMessageEndpoint::Builder("ApiGear/TbSame1/SameStruct1Interface/Client")
		.Handling<FTbSame1SameStruct1InterfaceInitMessage>(this, &UTbSame1SameStruct1InterfaceMsgBusClient::OnConnectionInit)
		.Handling<FTbSame1SameStruct1InterfaceServiceDisconnectMessage>(this, &UTbSame1SameStruct1InterfaceMsgBusClient::OnServiceClosedConnection)
		.Handling<FTbSame1SameStruct1InterfaceSig1SignalMessage>(this, &UTbSame1SameStruct1InterfaceMsgBusClient::OnSig1)
		.Handling<FTbSame1SameStruct1InterfaceProp1ChangedMessage>(this, &UTbSame1SameStruct1InterfaceMsgBusClient::OnProp1Changed)
		.Handling<FTbSame1SameStruct1InterfaceFunc1ReplyMessage>(this, &UTbSame1SameStruct1InterfaceMsgBusClient::OnFunc1Reply)
		.Build();
	// clang-format on

	DiscoverService();
}

void UTbSame1SameStruct1InterfaceMsgBusClient::Disconnect()
{
	if (!IsConnected())
	{
		return;
	}

	auto msg = new FTbSame1SameStruct1InterfaceClientDisconnectMessage();

	if (TbSame1SameStruct1InterfaceMsgBusEndpoint.IsValid())
	{
		TbSame1SameStruct1InterfaceMsgBusEndpoint->Send<FTbSame1SameStruct1InterfaceClientDisconnectMessage>(msg, EMessageFlags::Reliable,
			nullptr,
			TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
			FTimespan::Zero(),
			FDateTime::MaxValue());
	}

	TbSame1SameStruct1InterfaceMsgBusEndpoint.Reset();
	ServiceAddress.Invalidate();
	_ConnectionStatusChanged.Broadcast(false);
}

void UTbSame1SameStruct1InterfaceMsgBusClient::DiscoverService()
{
	if (TbSame1SameStruct1InterfaceMsgBusEndpoint.IsValid())
	{
		TbSame1SameStruct1InterfaceMsgBusEndpoint->Publish<FTbSame1SameStruct1InterfaceDiscoveryMessage>(new FTbSame1SameStruct1InterfaceDiscoveryMessage());
	}
}

bool UTbSame1SameStruct1InterfaceMsgBusClient::IsConnected() const
{
	return TbSame1SameStruct1InterfaceMsgBusEndpoint.IsValid() && ServiceAddress.IsValid();
}

void UTbSame1SameStruct1InterfaceMsgBusClient::OnConnectionInit(const FTbSame1SameStruct1InterfaceInitMessage& InInitMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (!ServiceAddress.IsValid())
	{
		ServiceAddress = Context->GetSender();
		const bool bProp1Changed = InInitMessage.Prop1 != Prop1;
		if (bProp1Changed)
		{
			Prop1 = InInitMessage.Prop1;
			Execute__GetSignals(this)->OnProp1Changed.Broadcast(Prop1);
		}

		_ConnectionStatusChanged.Broadcast(true);
	}
	else
	{
		UE_LOG(LogTbSame1SameStruct1InterfaceMsgBusClient, Error, TEXT("Got a second init message - should not happen"));
	}
}

void UTbSame1SameStruct1InterfaceMsgBusClient::OnServiceClosedConnection(const FTbSame1SameStruct1InterfaceServiceDisconnectMessage& /*InMessage*/, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		return;
	}

	ServiceAddress.Invalidate();
	_ConnectionStatusChanged.Broadcast(false);
}

FTbSame1Struct1 UTbSame1SameStruct1InterfaceMsgBusClient::GetProp1_Implementation() const
{
	return Prop1;
}

void UTbSame1SameStruct1InterfaceMsgBusClient::SetProp1_Implementation(const FTbSame1Struct1& InProp1)
{
	if (!IsConnected())
	{
		UE_LOG(LogTbSame1SameStruct1InterfaceMsgBusClient, Error, TEXT("Client has no connection to service."));
		return;
	}

	// only send change requests if the value changed -> reduce network load
	if (GetProp1_Implementation() == InProp1)
	{
		return;
	}

	// only send change requests if the value wasn't already sent -> reduce network load
	{
		FScopeLock Lock(&(_SentData->Prop1Mutex));
		if (_SentData->Prop1 == InProp1)
		{
			return;
		}
	}

	auto msg = new FTbSame1SameStruct1InterfaceSetProp1RequestMessage();
	msg->Prop1 = InProp1;

	if (TbSame1SameStruct1InterfaceMsgBusEndpoint.IsValid())
	{
		TbSame1SameStruct1InterfaceMsgBusEndpoint->Send<FTbSame1SameStruct1InterfaceSetProp1RequestMessage>(msg, EMessageFlags::Reliable,
			nullptr,
			TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
			FTimespan::Zero(),
			FDateTime::MaxValue());
		FScopeLock Lock(&(_SentData->Prop1Mutex));
		_SentData->Prop1 = InProp1;
	}
}

FTbSame1Struct1 UTbSame1SameStruct1InterfaceMsgBusClient::Func1_Implementation(const FTbSame1Struct1& InParam1)
{
	if (!IsConnected())
	{
		UE_LOG(LogTbSame1SameStruct1InterfaceMsgBusClient, Error, TEXT("Client has no connection to service."));

		return FTbSame1Struct1();
	}

	auto msg = new FTbSame1SameStruct1InterfaceFunc1RequestMessage();
	msg->RepsonseId = FGuid::NewGuid();
	msg->Param1 = InParam1;

	if (TbSame1SameStruct1InterfaceMsgBusEndpoint.IsValid())
	{
		TPromise<FTbSame1Struct1> Promise;
		StorePromise(msg->RepsonseId, Promise);

		TbSame1SameStruct1InterfaceMsgBusEndpoint->Send<FTbSame1SameStruct1InterfaceFunc1RequestMessage>(msg, EMessageFlags::Reliable,
			nullptr,
			TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
			FTimespan::Zero(),
			FDateTime::MaxValue());

		return Promise.GetFuture().Get();
	}

	return FTbSame1Struct1();
}

void UTbSame1SameStruct1InterfaceMsgBusClient::OnFunc1Reply(const FTbSame1SameStruct1InterfaceFunc1ReplyMessage& InFunc1ReplyMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	FulfillPromise(InFunc1ReplyMessage.RepsonseId, InFunc1ReplyMessage.Result);
}

void UTbSame1SameStruct1InterfaceMsgBusClient::OnSig1(const FTbSame1SameStruct1InterfaceSig1SignalMessage& InSig1Message, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogTbSame1SameStruct1InterfaceMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	Execute__GetSignals(this)->OnSig1Signal.Broadcast(InSig1Message.Param1);
	return;
}

void UTbSame1SameStruct1InterfaceMsgBusClient::OnProp1Changed(const FTbSame1SameStruct1InterfaceProp1ChangedMessage& InProp1Message, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogTbSame1SameStruct1InterfaceMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	const bool bProp1Changed = InProp1Message.Prop1 != Prop1;
	if (bProp1Changed)
	{
		Prop1 = InProp1Message.Prop1;
		Execute__GetSignals(this)->OnProp1Changed.Broadcast(Prop1);
	}
}

template <typename ResultType>
bool UTbSame1SameStruct1InterfaceMsgBusClient::StorePromise(const FGuid& Id, TPromise<ResultType>& Promise)
{
	FScopeLock Lock(&ReplyPromisesMapCS);
	return ReplyPromisesMap.Add(Id, &Promise) != nullptr;
}

template <typename ResultType>
bool UTbSame1SameStruct1InterfaceMsgBusClient::FulfillPromise(const FGuid& Id, const ResultType& Value)
{
	TPromise<ResultType>* PromisePtr = nullptr;

	{
		FScopeLock Lock(&ReplyPromisesMapCS);
		if (auto** Found = ReplyPromisesMap.Find(Id))
		{
			PromisePtr = static_cast<TPromise<ResultType>*>(*Found);
			ReplyPromisesMap.Remove(Id);
		}
	}

	if (PromisePtr)
	{
		PromisePtr->SetValue(Value);
		return true;
	}
	return false;
}

template bool UTbSame1SameStruct1InterfaceMsgBusClient::StorePromise<FTbSame1Struct1>(const FGuid& Id, TPromise<FTbSame1Struct1>& Promise);
template bool UTbSame1SameStruct1InterfaceMsgBusClient::FulfillPromise<FTbSame1Struct1>(const FGuid& Id, const FTbSame1Struct1& Value);
