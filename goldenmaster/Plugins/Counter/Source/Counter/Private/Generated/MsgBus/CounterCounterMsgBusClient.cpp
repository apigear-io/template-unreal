/**
Copyright 2021 ApiGear UG
Copyright 2021 Epic Games, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

////////////////////////////////
// WARNING AUTOGENERATED
// DO NOT MODIFY
///////////////////////////////

#include "Generated/MsgBus/CounterCounterMsgBusClient.h"
#include "Generated/MsgBus/CounterCounterMsgBusMessages.h"
#include "Async/Async.h"
#include "Engine/Engine.h"
#include "Misc/DateTime.h"
#include "MessageEndpointBuilder.h"
#include "MessageEndpoint.h"
#include "HAL/CriticalSection.h"

/**
   \brief data structure to hold the last sent property values
*/
struct CounterCounterPropertiesMsgBusData
{
	FCriticalSection VectorMutex;
	FCustomTypesVector3D Vector{FCustomTypesVector3D()};
	FCriticalSection ExternVectorMutex;
	FVector ExternVector{FVector(0.f, 0.f, 0.f)};
	FCriticalSection VectorArrayMutex;
	TArray<FCustomTypesVector3D> VectorArray{TArray<FCustomTypesVector3D>()};
	FCriticalSection ExternVectorArrayMutex;
	TArray<FVector> ExternVectorArray{TArray<FVector>()};
};
DEFINE_LOG_CATEGORY(LogCounterCounterMsgBusClient);

UCounterCounterMsgBusClient::UCounterCounterMsgBusClient()
	: UAbstractCounterCounter()
	, _SentData(MakePimpl<CounterCounterPropertiesMsgBusData>())
{
	/* m_sink = std::make_shared<FOLinkSink>("counter.Counter"); */
}

UCounterCounterMsgBusClient::~UCounterCounterMsgBusClient() = default;

void UCounterCounterMsgBusClient::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);

	Connect();
}

void UCounterCounterMsgBusClient::Deinitialize()
{
	Disconnect();

	Super::Deinitialize();
}

void UCounterCounterMsgBusClient::Connect()
{
	if (IsConnected())
	{
		return;
	}

	if (CounterCounterMsgBusEndpoint.IsValid() && !ServiceAddress.IsValid())
	{
		DiscoverService();
		return;
	}

	// clang-format off
	CounterCounterMsgBusEndpoint = FMessageEndpoint::Builder("ApiGear/Counter/Counter/Client")
		.Handling<FCounterCounterInitMessage>(this, &UCounterCounterMsgBusClient::OnConnectionInit)
		.Handling<FCounterCounterServiceDisconnectMessage>(this, &UCounterCounterMsgBusClient::OnServiceClosedConnection)
		.Handling<FCounterCounterValueChangedSignalMessage>(this, &UCounterCounterMsgBusClient::OnValueChanged)
		.Handling<FCounterCounterVectorChangedMessage>(this, &UCounterCounterMsgBusClient::OnVectorChanged)

		.Handling<FCounterCounterExternVectorChangedMessage>(this, &UCounterCounterMsgBusClient::OnExternVectorChanged)

		.Handling<FCounterCounterVectorArrayChangedMessage>(this, &UCounterCounterMsgBusClient::OnVectorArrayChanged)

		.Handling<FCounterCounterExternVectorArrayChangedMessage>(this, &UCounterCounterMsgBusClient::OnExternVectorArrayChanged)
		.Handling<FCounterCounterIncrementReplyMessage>(this, &UCounterCounterMsgBusClient::OnIncrementReply)
		.Handling<FCounterCounterIncrementArrayReplyMessage>(this, &UCounterCounterMsgBusClient::OnIncrementArrayReply)
		.Handling<FCounterCounterDecrementReplyMessage>(this, &UCounterCounterMsgBusClient::OnDecrementReply)
		.Handling<FCounterCounterDecrementArrayReplyMessage>(this, &UCounterCounterMsgBusClient::OnDecrementArrayReply)
		.Build();
	// clang-format on

	DiscoverService();
}

void UCounterCounterMsgBusClient::Disconnect()
{
	if (!IsConnected())
	{
		return;
	}

	auto msg = new FCounterCounterClientDisconnectMessage();

	if (CounterCounterMsgBusEndpoint.IsValid())
	{
		CounterCounterMsgBusEndpoint->Send<FCounterCounterClientDisconnectMessage>(msg, EMessageFlags::Reliable,
			nullptr,
			TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
			FTimespan::Zero(),
			FDateTime::MaxValue());
	}

	CounterCounterMsgBusEndpoint.Reset();
	ServiceAddress.Invalidate();
	_ConnectionStatusChanged.Broadcast(false);
}

void UCounterCounterMsgBusClient::DiscoverService()
{
	if (CounterCounterMsgBusEndpoint.IsValid())
	{
		CounterCounterMsgBusEndpoint->Publish<FCounterCounterDiscoveryMessage>(new FCounterCounterDiscoveryMessage());
	}
}

bool UCounterCounterMsgBusClient::IsConnected() const
{
	return CounterCounterMsgBusEndpoint.IsValid() && ServiceAddress.IsValid();
}

void UCounterCounterMsgBusClient::OnConnectionInit(const FCounterCounterInitMessage& InInitMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (!ServiceAddress.IsValid())
	{
		ServiceAddress = Context->GetSender();
		const bool bVectorChanged = InInitMessage.Vector != Vector;
		if (bVectorChanged)
		{
			Vector = InInitMessage.Vector;
			Execute__GetSignals(this)->OnVectorChanged.Broadcast(Vector);
		}

		const bool bExternVectorChanged = InInitMessage.ExternVector != ExternVector;
		if (bExternVectorChanged)
		{
			ExternVector = InInitMessage.ExternVector;
			Execute__GetSignals(this)->OnExternVectorChanged.Broadcast(ExternVector);
		}

		const bool bVectorArrayChanged = InInitMessage.VectorArray != VectorArray;
		if (bVectorArrayChanged)
		{
			VectorArray = InInitMessage.VectorArray;
			Execute__GetSignals(this)->OnVectorArrayChanged.Broadcast(VectorArray);
		}

		const bool bExternVectorArrayChanged = InInitMessage.ExternVectorArray != ExternVectorArray;
		if (bExternVectorArrayChanged)
		{
			ExternVectorArray = InInitMessage.ExternVectorArray;
			Execute__GetSignals(this)->OnExternVectorArrayChanged.Broadcast(ExternVectorArray);
		}

		_ConnectionStatusChanged.Broadcast(true);
	}
	else
	{
		UE_LOG(LogCounterCounterMsgBusClient, Error, TEXT("Got a second init message - should not happen"));
	}
}

void UCounterCounterMsgBusClient::OnServiceClosedConnection(const FCounterCounterServiceDisconnectMessage& /*InMessage*/, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		return;
	}

	ServiceAddress.Invalidate();
	_ConnectionStatusChanged.Broadcast(false);
}

FCustomTypesVector3D UCounterCounterMsgBusClient::GetVector_Implementation() const
{
	return Vector;
}

void UCounterCounterMsgBusClient::SetVector_Implementation(const FCustomTypesVector3D& InVector)
{
	if (!IsConnected())
	{
		UE_LOG(LogCounterCounterMsgBusClient, Error, TEXT("Client has no connection to service."));
		return;
	}

	// only send change requests if the value changed -> reduce network load
	if (GetVector_Implementation() == InVector)
	{
		return;
	}

	// only send change requests if the value wasn't already sent -> reduce network load
	{
		FScopeLock Lock(&(_SentData->VectorMutex));
		if (_SentData->Vector == InVector)
		{
			return;
		}
	}

	auto msg = new FCounterCounterSetVectorRequestMessage();
	msg->Vector = InVector;

	if (CounterCounterMsgBusEndpoint.IsValid())
	{
		CounterCounterMsgBusEndpoint->Send<FCounterCounterSetVectorRequestMessage>(msg, EMessageFlags::Reliable,
			nullptr,
			TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
			FTimespan::Zero(),
			FDateTime::MaxValue());
		FScopeLock Lock(&(_SentData->VectorMutex));
		_SentData->Vector = InVector;
	}
}

FVector UCounterCounterMsgBusClient::GetExternVector_Implementation() const
{
	return ExternVector;
}

void UCounterCounterMsgBusClient::SetExternVector_Implementation(const FVector& InExternVector)
{
	if (!IsConnected())
	{
		UE_LOG(LogCounterCounterMsgBusClient, Error, TEXT("Client has no connection to service."));
		return;
	}

	// only send change requests if the value changed -> reduce network load
	if (GetExternVector_Implementation() == InExternVector)
	{
		return;
	}

	// only send change requests if the value wasn't already sent -> reduce network load
	{
		FScopeLock Lock(&(_SentData->ExternVectorMutex));
		if (_SentData->ExternVector == InExternVector)
		{
			return;
		}
	}

	auto msg = new FCounterCounterSetExternVectorRequestMessage();
	msg->ExternVector = InExternVector;

	if (CounterCounterMsgBusEndpoint.IsValid())
	{
		CounterCounterMsgBusEndpoint->Send<FCounterCounterSetExternVectorRequestMessage>(msg, EMessageFlags::Reliable,
			nullptr,
			TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
			FTimespan::Zero(),
			FDateTime::MaxValue());
		FScopeLock Lock(&(_SentData->ExternVectorMutex));
		_SentData->ExternVector = InExternVector;
	}
}

TArray<FCustomTypesVector3D> UCounterCounterMsgBusClient::GetVectorArray_Implementation() const
{
	return VectorArray;
}

void UCounterCounterMsgBusClient::SetVectorArray_Implementation(const TArray<FCustomTypesVector3D>& InVectorArray)
{
	if (!IsConnected())
	{
		UE_LOG(LogCounterCounterMsgBusClient, Error, TEXT("Client has no connection to service."));
		return;
	}

	// only send change requests if the value changed -> reduce network load
	if (GetVectorArray_Implementation() == InVectorArray)
	{
		return;
	}

	// only send change requests if the value wasn't already sent -> reduce network load
	{
		FScopeLock Lock(&(_SentData->VectorArrayMutex));
		if (_SentData->VectorArray == InVectorArray)
		{
			return;
		}
	}

	auto msg = new FCounterCounterSetVectorArrayRequestMessage();
	msg->VectorArray = InVectorArray;

	if (CounterCounterMsgBusEndpoint.IsValid())
	{
		CounterCounterMsgBusEndpoint->Send<FCounterCounterSetVectorArrayRequestMessage>(msg, EMessageFlags::Reliable,
			nullptr,
			TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
			FTimespan::Zero(),
			FDateTime::MaxValue());
		FScopeLock Lock(&(_SentData->VectorArrayMutex));
		_SentData->VectorArray = InVectorArray;
	}
}

TArray<FVector> UCounterCounterMsgBusClient::GetExternVectorArray_Implementation() const
{
	return ExternVectorArray;
}

void UCounterCounterMsgBusClient::SetExternVectorArray_Implementation(const TArray<FVector>& InExternVectorArray)
{
	if (!IsConnected())
	{
		UE_LOG(LogCounterCounterMsgBusClient, Error, TEXT("Client has no connection to service."));
		return;
	}

	// only send change requests if the value changed -> reduce network load
	if (GetExternVectorArray_Implementation() == InExternVectorArray)
	{
		return;
	}

	// only send change requests if the value wasn't already sent -> reduce network load
	{
		FScopeLock Lock(&(_SentData->ExternVectorArrayMutex));
		if (_SentData->ExternVectorArray == InExternVectorArray)
		{
			return;
		}
	}

	auto msg = new FCounterCounterSetExternVectorArrayRequestMessage();
	msg->ExternVectorArray = InExternVectorArray;

	if (CounterCounterMsgBusEndpoint.IsValid())
	{
		CounterCounterMsgBusEndpoint->Send<FCounterCounterSetExternVectorArrayRequestMessage>(msg, EMessageFlags::Reliable,
			nullptr,
			TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
			FTimespan::Zero(),
			FDateTime::MaxValue());
		FScopeLock Lock(&(_SentData->ExternVectorArrayMutex));
		_SentData->ExternVectorArray = InExternVectorArray;
	}
}

FVector UCounterCounterMsgBusClient::Increment_Implementation(const FVector& InVec)
{
	if (!IsConnected())
	{
		UE_LOG(LogCounterCounterMsgBusClient, Error, TEXT("Client has no connection to service."));

		return FVector(0.f, 0.f, 0.f);
	}

	auto msg = new FCounterCounterIncrementRequestMessage();
	msg->RepsonseId = FGuid::NewGuid();
	msg->Vec = InVec;

	if (CounterCounterMsgBusEndpoint.IsValid())
	{
		TPromise<FVector> Promise;
		StorePromise(msg->RepsonseId, Promise);

		CounterCounterMsgBusEndpoint->Send<FCounterCounterIncrementRequestMessage>(msg, EMessageFlags::Reliable,
			nullptr,
			TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
			FTimespan::Zero(),
			FDateTime::MaxValue());

		return Promise.GetFuture().Get();
	}

	return FVector(0.f, 0.f, 0.f);
}

void UCounterCounterMsgBusClient::OnIncrementReply(const FCounterCounterIncrementReplyMessage& InIncrementReplyMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	FulfillPromise(InIncrementReplyMessage.RepsonseId, InIncrementReplyMessage.Result);
}

TArray<FVector> UCounterCounterMsgBusClient::IncrementArray_Implementation(const TArray<FVector>& InVec)
{
	if (!IsConnected())
	{
		UE_LOG(LogCounterCounterMsgBusClient, Error, TEXT("Client has no connection to service."));

		return TArray<FVector>();
	}

	auto msg = new FCounterCounterIncrementArrayRequestMessage();
	msg->RepsonseId = FGuid::NewGuid();
	msg->Vec = InVec;

	if (CounterCounterMsgBusEndpoint.IsValid())
	{
		TPromise<TArray<FVector>> Promise;
		StorePromise(msg->RepsonseId, Promise);

		CounterCounterMsgBusEndpoint->Send<FCounterCounterIncrementArrayRequestMessage>(msg, EMessageFlags::Reliable,
			nullptr,
			TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
			FTimespan::Zero(),
			FDateTime::MaxValue());

		return Promise.GetFuture().Get();
	}

	return TArray<FVector>();
}

void UCounterCounterMsgBusClient::OnIncrementArrayReply(const FCounterCounterIncrementArrayReplyMessage& InIncrementArrayReplyMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	FulfillPromise(InIncrementArrayReplyMessage.RepsonseId, InIncrementArrayReplyMessage.Result);
}

FCustomTypesVector3D UCounterCounterMsgBusClient::Decrement_Implementation(const FCustomTypesVector3D& InVec)
{
	if (!IsConnected())
	{
		UE_LOG(LogCounterCounterMsgBusClient, Error, TEXT("Client has no connection to service."));

		return FCustomTypesVector3D();
	}

	auto msg = new FCounterCounterDecrementRequestMessage();
	msg->RepsonseId = FGuid::NewGuid();
	msg->Vec = InVec;

	if (CounterCounterMsgBusEndpoint.IsValid())
	{
		TPromise<FCustomTypesVector3D> Promise;
		StorePromise(msg->RepsonseId, Promise);

		CounterCounterMsgBusEndpoint->Send<FCounterCounterDecrementRequestMessage>(msg, EMessageFlags::Reliable,
			nullptr,
			TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
			FTimespan::Zero(),
			FDateTime::MaxValue());

		return Promise.GetFuture().Get();
	}

	return FCustomTypesVector3D();
}

void UCounterCounterMsgBusClient::OnDecrementReply(const FCounterCounterDecrementReplyMessage& InDecrementReplyMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	FulfillPromise(InDecrementReplyMessage.RepsonseId, InDecrementReplyMessage.Result);
}

TArray<FCustomTypesVector3D> UCounterCounterMsgBusClient::DecrementArray_Implementation(const TArray<FCustomTypesVector3D>& InVec)
{
	if (!IsConnected())
	{
		UE_LOG(LogCounterCounterMsgBusClient, Error, TEXT("Client has no connection to service."));

		return TArray<FCustomTypesVector3D>();
	}

	auto msg = new FCounterCounterDecrementArrayRequestMessage();
	msg->RepsonseId = FGuid::NewGuid();
	msg->Vec = InVec;

	if (CounterCounterMsgBusEndpoint.IsValid())
	{
		TPromise<TArray<FCustomTypesVector3D>> Promise;
		StorePromise(msg->RepsonseId, Promise);

		CounterCounterMsgBusEndpoint->Send<FCounterCounterDecrementArrayRequestMessage>(msg, EMessageFlags::Reliable,
			nullptr,
			TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
			FTimespan::Zero(),
			FDateTime::MaxValue());

		return Promise.GetFuture().Get();
	}

	return TArray<FCustomTypesVector3D>();
}

void UCounterCounterMsgBusClient::OnDecrementArrayReply(const FCounterCounterDecrementArrayReplyMessage& InDecrementArrayReplyMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	FulfillPromise(InDecrementArrayReplyMessage.RepsonseId, InDecrementArrayReplyMessage.Result);
}

void UCounterCounterMsgBusClient::OnValueChanged(const FCounterCounterValueChangedSignalMessage& InValueChangedMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogCounterCounterMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	Execute__GetSignals(this)->OnValueChangedSignal.Broadcast(InValueChangedMessage.Vector, InValueChangedMessage.ExternVector, InValueChangedMessage.VectorArray, InValueChangedMessage.ExternVectorArray);
	return;
}

void UCounterCounterMsgBusClient::OnVectorChanged(const FCounterCounterVectorChangedMessage& InVectorMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogCounterCounterMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	const bool bVectorChanged = InVectorMessage.Vector != Vector;
	if (bVectorChanged)
	{
		Vector = InVectorMessage.Vector;
		Execute__GetSignals(this)->OnVectorChanged.Broadcast(Vector);
	}
}

void UCounterCounterMsgBusClient::OnExternVectorChanged(const FCounterCounterExternVectorChangedMessage& InExternVectorMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogCounterCounterMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	const bool bExternVectorChanged = InExternVectorMessage.ExternVector != ExternVector;
	if (bExternVectorChanged)
	{
		ExternVector = InExternVectorMessage.ExternVector;
		Execute__GetSignals(this)->OnExternVectorChanged.Broadcast(ExternVector);
	}
}

void UCounterCounterMsgBusClient::OnVectorArrayChanged(const FCounterCounterVectorArrayChangedMessage& InVectorArrayMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogCounterCounterMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	const bool bVectorArrayChanged = InVectorArrayMessage.VectorArray != VectorArray;
	if (bVectorArrayChanged)
	{
		VectorArray = InVectorArrayMessage.VectorArray;
		Execute__GetSignals(this)->OnVectorArrayChanged.Broadcast(VectorArray);
	}
}

void UCounterCounterMsgBusClient::OnExternVectorArrayChanged(const FCounterCounterExternVectorArrayChangedMessage& InExternVectorArrayMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogCounterCounterMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	const bool bExternVectorArrayChanged = InExternVectorArrayMessage.ExternVectorArray != ExternVectorArray;
	if (bExternVectorArrayChanged)
	{
		ExternVectorArray = InExternVectorArrayMessage.ExternVectorArray;
		Execute__GetSignals(this)->OnExternVectorArrayChanged.Broadcast(ExternVectorArray);
	}
}

template <typename ResultType>
bool UCounterCounterMsgBusClient::StorePromise(const FGuid& Id, TPromise<ResultType>& Promise)
{
	FScopeLock Lock(&ReplyPromisesMapCS);
	return ReplyPromisesMap.Add(Id, &Promise) != nullptr;
}

template <typename ResultType>
bool UCounterCounterMsgBusClient::FulfillPromise(const FGuid& Id, const ResultType& Value)
{
	TPromise<ResultType>* PromisePtr = nullptr;

	{
		FScopeLock Lock(&ReplyPromisesMapCS);
		if (auto** Found = ReplyPromisesMap.Find(Id))
		{
			PromisePtr = static_cast<TPromise<ResultType>*>(*Found);
			ReplyPromisesMap.Remove(Id);
		}
	}

	if (PromisePtr)
	{
		PromisePtr->SetValue(Value);
		return true;
	}
	return false;
}

template bool UCounterCounterMsgBusClient::StorePromise<FCustomTypesVector3D>(const FGuid& Id, TPromise<FCustomTypesVector3D>& Promise);
template bool UCounterCounterMsgBusClient::FulfillPromise<FCustomTypesVector3D>(const FGuid& Id, const FCustomTypesVector3D& Value);
template bool UCounterCounterMsgBusClient::StorePromise<FVector>(const FGuid& Id, TPromise<FVector>& Promise);
template bool UCounterCounterMsgBusClient::FulfillPromise<FVector>(const FGuid& Id, const FVector& Value);
template bool UCounterCounterMsgBusClient::StorePromise<TArray<FCustomTypesVector3D>>(const FGuid& Id, TPromise<TArray<FCustomTypesVector3D>>& Promise);
template bool UCounterCounterMsgBusClient::FulfillPromise<TArray<FCustomTypesVector3D>>(const FGuid& Id, const TArray<FCustomTypesVector3D>& Value);
template bool UCounterCounterMsgBusClient::StorePromise<TArray<FVector>>(const FGuid& Id, TPromise<TArray<FVector>>& Promise);
template bool UCounterCounterMsgBusClient::FulfillPromise<TArray<FVector>>(const FGuid& Id, const TArray<FVector>& Value);
