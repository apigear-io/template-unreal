/**
Copyright 2021 ApiGear UG
Copyright 2021 Epic Games, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

////////////////////////////////
// WARNING AUTOGENERATED
// DO NOT MODIFY
///////////////////////////////

#include "TbSimple/Generated/MsgBus/TbSimpleNoOperationsInterfaceMsgBusClient.h"
#include "TbSimple/Generated/MsgBus/TbSimpleNoOperationsInterfaceMsgBusMessages.h"
#include "Async/Async.h"
#include "Engine/Engine.h"
#include "TimerManager.h"
#include "Misc/DateTime.h"
#include "GenericPlatform/GenericPlatformMath.h"
#include "GenericPlatform/GenericPlatformTime.h"
#include "MessageEndpointBuilder.h"
#include "MessageEndpoint.h"
#include <atomic>

/**
   \brief data structure to hold the last sent property values
*/
struct TbSimpleNoOperationsInterfacePropertiesMsgBusData
{
	std::atomic<bool> bPropBool{false};
	std::atomic<int32> PropInt{0};
};
DEFINE_LOG_CATEGORY(LogTbSimpleNoOperationsInterfaceMsgBusClient);

UTbSimpleNoOperationsInterfaceMsgBusClient::UTbSimpleNoOperationsInterfaceMsgBusClient()
	: UAbstractTbSimpleNoOperationsInterface()
	, _SentData(MakePimpl<TbSimpleNoOperationsInterfacePropertiesMsgBusData>())
{
	PingRTTBuffer.SetNumZeroed(PING_RTT_BUFFER_SIZE);
}

UTbSimpleNoOperationsInterfaceMsgBusClient::~UTbSimpleNoOperationsInterfaceMsgBusClient() = default;

void UTbSimpleNoOperationsInterfaceMsgBusClient::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);
}

void UTbSimpleNoOperationsInterfaceMsgBusClient::Deinitialize()
{
	_Disconnect();

	Super::Deinitialize();
}

void UTbSimpleNoOperationsInterfaceMsgBusClient::_Connect()
{
	if (!_HeartbeatTimerHandle.IsValid() && GetWorld())
	{
		GetWorld()->GetTimerManager().SetTimer(_HeartbeatTimerHandle, this, &UTbSimpleNoOperationsInterfaceMsgBusClient::_OnHeartbeat, _HeartbeatIntervalMS / 1000.0f, true);
	}

	if (_IsConnected())
	{
		UE_LOG(LogTbSimpleNoOperationsInterfaceMsgBusClient, Log, TEXT("Already connected, cannot connect again."));
		return;
	}

	if (TbSimpleNoOperationsInterfaceMsgBusEndpoint.IsValid() && !ServiceAddress.IsValid())
	{
		_DiscoverService();
		return;
	}

	// clang-format off
	TbSimpleNoOperationsInterfaceMsgBusEndpoint = FMessageEndpoint::Builder("ApiGear/TbSimple/NoOperationsInterface/Client")
		.Handling<FTbSimpleNoOperationsInterfaceInitMessage>(this, &UTbSimpleNoOperationsInterfaceMsgBusClient::OnConnectionInit)
		.Handling<FTbSimpleNoOperationsInterfacePongMessage>(this, &UTbSimpleNoOperationsInterfaceMsgBusClient::OnPong)
		.Handling<FTbSimpleNoOperationsInterfaceServiceDisconnectMessage>(this, &UTbSimpleNoOperationsInterfaceMsgBusClient::OnServiceClosedConnection)
		.Handling<FTbSimpleNoOperationsInterfaceSigVoidSignalMessage>(this, &UTbSimpleNoOperationsInterfaceMsgBusClient::OnSigVoid)
		.Handling<FTbSimpleNoOperationsInterfaceSigBoolSignalMessage>(this, &UTbSimpleNoOperationsInterfaceMsgBusClient::OnSigBool)
		.Handling<FTbSimpleNoOperationsInterfacePropBoolChangedMessage>(this, &UTbSimpleNoOperationsInterfaceMsgBusClient::OnPropBoolChanged)
		.Handling<FTbSimpleNoOperationsInterfacePropIntChangedMessage>(this, &UTbSimpleNoOperationsInterfaceMsgBusClient::OnPropIntChanged)
		.Build();
	// clang-format on

	_DiscoverService();
}

void UTbSimpleNoOperationsInterfaceMsgBusClient::_Disconnect()
{
	_LastHbTimestamp = 0.0f;
	if (_HeartbeatTimerHandle.IsValid() && GetWorld())
	{
		GetWorld()->GetTimerManager().ClearTimer(_HeartbeatTimerHandle);
	}

	if (!_IsConnected())
	{
		return;
	}

	auto msg = new FTbSimpleNoOperationsInterfaceClientDisconnectMessage();

	TbSimpleNoOperationsInterfaceMsgBusEndpoint->Send<FTbSimpleNoOperationsInterfaceClientDisconnectMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());

	TbSimpleNoOperationsInterfaceMsgBusEndpoint.Reset();
	ServiceAddress.Invalidate();
	_ConnectionStatusChanged.Broadcast(false);
}

void UTbSimpleNoOperationsInterfaceMsgBusClient::_DiscoverService()
{
	if (!TbSimpleNoOperationsInterfaceMsgBusEndpoint.IsValid())
	{
		return;
	}

	auto msg = new FTbSimpleNoOperationsInterfaceDiscoveryMessage();
	TbSimpleNoOperationsInterfaceMsgBusEndpoint->Publish<FTbSimpleNoOperationsInterfaceDiscoveryMessage>(msg);
}

bool UTbSimpleNoOperationsInterfaceMsgBusClient::_IsConnected() const
{
	return TbSimpleNoOperationsInterfaceMsgBusEndpoint.IsValid() && ServiceAddress.IsValid();
}

void UTbSimpleNoOperationsInterfaceMsgBusClient::OnConnectionInit(const FTbSimpleNoOperationsInterfaceInitMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress.IsValid())
	{
		UE_LOG(LogTbSimpleNoOperationsInterfaceMsgBusClient, Warning, TEXT("Got a second init message - should not happen"));
		return;
	}

	ServiceAddress = Context->GetSender();
	// reset ping stats for a new connection
	PingRTTBuffer.Empty();
	PingRTTBuffer.SetNumZeroed(PING_RTT_BUFFER_SIZE);
	CurrentPingCounter = 0;
	Stats.CurrentRTT_MS = 0.0f;
	Stats.AverageRTT_MS = 0.0f;
	Stats.MaxRTT_MS = 0.0f;
	Stats.MinRTT_MS = 0.0f;

	const bool b_ClientPingIntervalMSChanged = InMessage._ClientPingIntervalMS != _HeartbeatIntervalMS;
	if (b_ClientPingIntervalMSChanged)
	{
		_HeartbeatIntervalMS = InMessage._ClientPingIntervalMS;

		if (_HeartbeatTimerHandle.IsValid() && GetWorld())
		{
			GetWorld()->GetTimerManager().ClearTimer(_HeartbeatTimerHandle);
		}

		if (!_HeartbeatTimerHandle.IsValid() && GetWorld())
		{
			GetWorld()->GetTimerManager().SetTimer(_HeartbeatTimerHandle, this, &UTbSimpleNoOperationsInterfaceMsgBusClient::_OnHeartbeat, _HeartbeatIntervalMS / 1000.0f, true);
		}
	}
	const bool bbPropBoolChanged = InMessage.bPropBool != bPropBool;
	if (bbPropBoolChanged)
	{
		bPropBool = InMessage.bPropBool;
		Execute__GetSignals(this)->OnPropBoolChanged.Broadcast(bPropBool);
	}

	const bool bPropIntChanged = InMessage.PropInt != PropInt;
	if (bPropIntChanged)
	{
		PropInt = InMessage.PropInt;
		Execute__GetSignals(this)->OnPropIntChanged.Broadcast(PropInt);
	}

	_ConnectionStatusChanged.Broadcast(true);
}

void UTbSimpleNoOperationsInterfaceMsgBusClient::_OnHeartbeat()
{
	if (_LastHbTimestamp > 0.1f)
	{
		double Delta = (FPlatformTime::Seconds() - _LastHbTimestamp) * 1000;

		if (Delta > 2 * _HeartbeatIntervalMS)
		{
			// service seems to be dead or not responding - reset connection
			ServiceAddress.Invalidate();
			_LastHbTimestamp = 0.0f;
		}
	}

	if (!_IsConnected())
	{
		UE_LOG(LogTbSimpleNoOperationsInterfaceMsgBusClient, Warning, TEXT("Heartbeat failed. Client has no connection to service. Reconnecting ..."));

		_Connect();
		return;
	}

	auto msg = new FTbSimpleNoOperationsInterfacePingMessage();
	msg->Timestamp = FPlatformTime::Seconds();

	TbSimpleNoOperationsInterfaceMsgBusEndpoint->Send<FTbSimpleNoOperationsInterfacePingMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());
}

float UTbSimpleNoOperationsInterfaceMsgBusClient::_CalculateAverageRTT() const
{
	if (CurrentPingCounter == 0)
	{
		return 0.0f;
	}

	float TotalRTT = 0.0f;

	for (const float& RTT : PingRTTBuffer)
	{
		TotalRTT += RTT;
	}

	return CurrentPingCounter > 0 ? TotalRTT / CurrentPingCounter : 0.0f;
}

void UTbSimpleNoOperationsInterfaceMsgBusClient::OnPong(const FTbSimpleNoOperationsInterfacePongMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	_LastHbTimestamp = InMessage.Timestamp;

	const double Current = FPlatformTime::Seconds();
	const double DeltaMS = (Current - InMessage.Timestamp) * 1000.0f;

	Stats.CurrentRTT_MS = DeltaMS;
	if (CurrentPingCounter < PING_RTT_BUFFER_SIZE)
	{
		CurrentPingCounter++;
	}
	PingRTTBuffer.RemoveAt(0);
	PingRTTBuffer.Add(Stats.CurrentRTT_MS);
	Stats.AverageRTT_MS = _CalculateAverageRTT();
	Stats.MaxRTT_MS = FGenericPlatformMath::Max(Stats.MaxRTT_MS, Stats.CurrentRTT_MS);
	Stats.MinRTT_MS = FGenericPlatformMath::Min(Stats.MinRTT_MS, Stats.CurrentRTT_MS);

	_StatsUpdated.Broadcast(Stats);
}

const FTbSimpleNoOperationsInterfaceStats& UTbSimpleNoOperationsInterfaceMsgBusClient::_GetStats() const
{
	return Stats;
}

void UTbSimpleNoOperationsInterfaceMsgBusClient::OnServiceClosedConnection(const FTbSimpleNoOperationsInterfaceServiceDisconnectMessage& /*InMessage*/, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		return;
	}

	ServiceAddress.Invalidate();
	_ConnectionStatusChanged.Broadcast(false);
}

bool UTbSimpleNoOperationsInterfaceMsgBusClient::GetPropBool_Implementation() const
{
	return bPropBool;
}

void UTbSimpleNoOperationsInterfaceMsgBusClient::SetPropBool_Implementation(bool bInPropBool)
{
	if (!_IsConnected())
	{
		UE_LOG(LogTbSimpleNoOperationsInterfaceMsgBusClient, Error, TEXT("Client has no connection to service."));
		return;
	}

	// only send change requests if the value changed -> reduce network load
	if (GetPropBool_Implementation() == bInPropBool)
	{
		return;
	}

	// only send change requests if the value wasn't already sent -> reduce network load
	if (_SentData->bPropBool == bInPropBool)
	{
		return;
	}

	auto msg = new FTbSimpleNoOperationsInterfaceSetPropBoolRequestMessage();
	msg->bPropBool = bInPropBool;

	TbSimpleNoOperationsInterfaceMsgBusEndpoint->Send<FTbSimpleNoOperationsInterfaceSetPropBoolRequestMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());
	_SentData->bPropBool = bInPropBool;
}

int32 UTbSimpleNoOperationsInterfaceMsgBusClient::GetPropInt_Implementation() const
{
	return PropInt;
}

void UTbSimpleNoOperationsInterfaceMsgBusClient::SetPropInt_Implementation(int32 InPropInt)
{
	if (!_IsConnected())
	{
		UE_LOG(LogTbSimpleNoOperationsInterfaceMsgBusClient, Error, TEXT("Client has no connection to service."));
		return;
	}

	// only send change requests if the value changed -> reduce network load
	if (GetPropInt_Implementation() == InPropInt)
	{
		return;
	}

	// only send change requests if the value wasn't already sent -> reduce network load
	if (_SentData->PropInt == InPropInt)
	{
		return;
	}

	auto msg = new FTbSimpleNoOperationsInterfaceSetPropIntRequestMessage();
	msg->PropInt = InPropInt;

	TbSimpleNoOperationsInterfaceMsgBusEndpoint->Send<FTbSimpleNoOperationsInterfaceSetPropIntRequestMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());
	_SentData->PropInt = InPropInt;
}

void UTbSimpleNoOperationsInterfaceMsgBusClient::OnSigVoid(const FTbSimpleNoOperationsInterfaceSigVoidSignalMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogTbSimpleNoOperationsInterfaceMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	Execute__GetSignals(this)->OnSigVoidSignal.Broadcast();
	return;
}

void UTbSimpleNoOperationsInterfaceMsgBusClient::OnSigBool(const FTbSimpleNoOperationsInterfaceSigBoolSignalMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogTbSimpleNoOperationsInterfaceMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	Execute__GetSignals(this)->OnSigBoolSignal.Broadcast(InMessage.bParamBool);
	return;
}

void UTbSimpleNoOperationsInterfaceMsgBusClient::OnPropBoolChanged(const FTbSimpleNoOperationsInterfacePropBoolChangedMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogTbSimpleNoOperationsInterfaceMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	const bool bbPropBoolChanged = InMessage.bPropBool != bPropBool;
	if (bbPropBoolChanged)
	{
		bPropBool = InMessage.bPropBool;
		Execute__GetSignals(this)->OnPropBoolChanged.Broadcast(bPropBool);
	}
}

void UTbSimpleNoOperationsInterfaceMsgBusClient::OnPropIntChanged(const FTbSimpleNoOperationsInterfacePropIntChangedMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogTbSimpleNoOperationsInterfaceMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	const bool bPropIntChanged = InMessage.PropInt != PropInt;
	if (bPropIntChanged)
	{
		PropInt = InMessage.PropInt;
		Execute__GetSignals(this)->OnPropIntChanged.Broadcast(PropInt);
	}
}
