/**
Copyright 2021 ApiGear UG
Copyright 2021 Epic Games, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

////////////////////////////////
// WARNING AUTOGENERATED
// DO NOT MODIFY
///////////////////////////////

#include "Generated/MsgBus/TbSimpleNoSignalsInterfaceMsgBusClient.h"
#include "Generated/MsgBus/TbSimpleNoSignalsInterfaceMsgBusMessages.h"
#include "Async/Async.h"
#include "Engine/Engine.h"
#include "Misc/DateTime.h"
#include "MessageEndpointBuilder.h"
#include "MessageEndpoint.h"
#include <atomic>

/**
   \brief data structure to hold the last sent property values
*/
struct TbSimpleNoSignalsInterfacePropertiesMsgBusData
{
	std::atomic<bool> bPropBool{false};
	std::atomic<int32> PropInt{0};
};
DEFINE_LOG_CATEGORY(LogTbSimpleNoSignalsInterfaceMsgBusClient);

UTbSimpleNoSignalsInterfaceMsgBusClient::UTbSimpleNoSignalsInterfaceMsgBusClient()
	: UAbstractTbSimpleNoSignalsInterface()
	, _SentData(MakePimpl<TbSimpleNoSignalsInterfacePropertiesMsgBusData>())
{
	/* m_sink = std::make_shared<FOLinkSink>("tb.simple.NoSignalsInterface"); */
}

UTbSimpleNoSignalsInterfaceMsgBusClient::~UTbSimpleNoSignalsInterfaceMsgBusClient() = default;

void UTbSimpleNoSignalsInterfaceMsgBusClient::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);

	Connect();
}

void UTbSimpleNoSignalsInterfaceMsgBusClient::Deinitialize()
{
	Disconnect();

	Super::Deinitialize();
}

void UTbSimpleNoSignalsInterfaceMsgBusClient::Connect()
{
	if (IsConnected())
	{
		return;
	}

	if (TbSimpleNoSignalsInterfaceMsgBusEndpoint.IsValid() && !ServiceAddress.IsValid())
	{
		DiscoverService();
		return;
	}

	// clang-format off
	TbSimpleNoSignalsInterfaceMsgBusEndpoint = FMessageEndpoint::Builder("ApiGear/TbSimple/NoSignalsInterface/Client")
		.Handling<FTbSimpleNoSignalsInterfaceInitMessage>(this, &UTbSimpleNoSignalsInterfaceMsgBusClient::OnConnectionInit)
		.Handling<FTbSimpleNoSignalsInterfaceServiceDisconnectMessage>(this, &UTbSimpleNoSignalsInterfaceMsgBusClient::OnServiceClosedConnection)
		.Handling<FTbSimpleNoSignalsInterfacePropBoolChangedMessage>(this, &UTbSimpleNoSignalsInterfaceMsgBusClient::OnPropBoolChanged)

		.Handling<FTbSimpleNoSignalsInterfacePropIntChangedMessage>(this, &UTbSimpleNoSignalsInterfaceMsgBusClient::OnPropIntChanged)
		.Handling<FTbSimpleNoSignalsInterfaceFuncBoolReplyMessage>(this, &UTbSimpleNoSignalsInterfaceMsgBusClient::OnFuncBoolReply)
		.Build();
	// clang-format on

	DiscoverService();
}

void UTbSimpleNoSignalsInterfaceMsgBusClient::Disconnect()
{
	if (!IsConnected())
	{
		return;
	}

	auto msg = new FTbSimpleNoSignalsInterfaceClientDisconnectMessage();

	if (TbSimpleNoSignalsInterfaceMsgBusEndpoint.IsValid())
	{
		TbSimpleNoSignalsInterfaceMsgBusEndpoint->Send<FTbSimpleNoSignalsInterfaceClientDisconnectMessage>(msg, EMessageFlags::Reliable,
			nullptr,
			TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
			FTimespan::Zero(),
			FDateTime::MaxValue());
	}

	TbSimpleNoSignalsInterfaceMsgBusEndpoint.Reset();
	ServiceAddress.Invalidate();
	_ConnectionStatusChanged.Broadcast(false);
}

void UTbSimpleNoSignalsInterfaceMsgBusClient::DiscoverService()
{
	if (TbSimpleNoSignalsInterfaceMsgBusEndpoint.IsValid())
	{
		TbSimpleNoSignalsInterfaceMsgBusEndpoint->Publish<FTbSimpleNoSignalsInterfaceDiscoveryMessage>(new FTbSimpleNoSignalsInterfaceDiscoveryMessage());
	}
}

bool UTbSimpleNoSignalsInterfaceMsgBusClient::IsConnected() const
{
	return TbSimpleNoSignalsInterfaceMsgBusEndpoint.IsValid() && ServiceAddress.IsValid();
}

void UTbSimpleNoSignalsInterfaceMsgBusClient::OnConnectionInit(const FTbSimpleNoSignalsInterfaceInitMessage& InInitMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (!ServiceAddress.IsValid())
	{
		ServiceAddress = Context->GetSender();
		const bool bbPropBoolChanged = InInitMessage.bPropBool != bPropBool;
		if (bbPropBoolChanged)
		{
			bPropBool = InInitMessage.bPropBool;
			Execute__GetSignals(this)->OnPropBoolChanged.Broadcast(bPropBool);
		}

		const bool bPropIntChanged = InInitMessage.PropInt != PropInt;
		if (bPropIntChanged)
		{
			PropInt = InInitMessage.PropInt;
			Execute__GetSignals(this)->OnPropIntChanged.Broadcast(PropInt);
		}

		_ConnectionStatusChanged.Broadcast(true);
	}
	else
	{
		UE_LOG(LogTbSimpleNoSignalsInterfaceMsgBusClient, Error, TEXT("Got a second init message - should not happen"));
	}
}

void UTbSimpleNoSignalsInterfaceMsgBusClient::OnServiceClosedConnection(const FTbSimpleNoSignalsInterfaceServiceDisconnectMessage& /*InMessage*/, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		return;
	}

	ServiceAddress.Invalidate();
	_ConnectionStatusChanged.Broadcast(false);
}

bool UTbSimpleNoSignalsInterfaceMsgBusClient::GetPropBool_Implementation() const
{
	return bPropBool;
}

void UTbSimpleNoSignalsInterfaceMsgBusClient::SetPropBool_Implementation(bool bInPropBool)
{
	if (!IsConnected())
	{
		UE_LOG(LogTbSimpleNoSignalsInterfaceMsgBusClient, Error, TEXT("Client has no connection to service."));
		return;
	}

	// only send change requests if the value changed -> reduce network load
	if (GetPropBool_Implementation() == bInPropBool)
	{
		return;
	}

	// only send change requests if the value wasn't already sent -> reduce network load
	if (_SentData->bPropBool == bInPropBool)
	{
		return;
	}

	auto msg = new FTbSimpleNoSignalsInterfaceSetPropBoolRequestMessage();
	msg->bPropBool = bInPropBool;

	if (TbSimpleNoSignalsInterfaceMsgBusEndpoint.IsValid())
	{
		TbSimpleNoSignalsInterfaceMsgBusEndpoint->Send<FTbSimpleNoSignalsInterfaceSetPropBoolRequestMessage>(msg, EMessageFlags::Reliable,
			nullptr,
			TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
			FTimespan::Zero(),
			FDateTime::MaxValue());
		_SentData->bPropBool = bInPropBool;
	}
}

int32 UTbSimpleNoSignalsInterfaceMsgBusClient::GetPropInt_Implementation() const
{
	return PropInt;
}

void UTbSimpleNoSignalsInterfaceMsgBusClient::SetPropInt_Implementation(int32 InPropInt)
{
	if (!IsConnected())
	{
		UE_LOG(LogTbSimpleNoSignalsInterfaceMsgBusClient, Error, TEXT("Client has no connection to service."));
		return;
	}

	// only send change requests if the value changed -> reduce network load
	if (GetPropInt_Implementation() == InPropInt)
	{
		return;
	}

	// only send change requests if the value wasn't already sent -> reduce network load
	if (_SentData->PropInt == InPropInt)
	{
		return;
	}

	auto msg = new FTbSimpleNoSignalsInterfaceSetPropIntRequestMessage();
	msg->PropInt = InPropInt;

	if (TbSimpleNoSignalsInterfaceMsgBusEndpoint.IsValid())
	{
		TbSimpleNoSignalsInterfaceMsgBusEndpoint->Send<FTbSimpleNoSignalsInterfaceSetPropIntRequestMessage>(msg, EMessageFlags::Reliable,
			nullptr,
			TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
			FTimespan::Zero(),
			FDateTime::MaxValue());
		_SentData->PropInt = InPropInt;
	}
}

void UTbSimpleNoSignalsInterfaceMsgBusClient::FuncVoid_Implementation()
{
	if (!IsConnected())
	{
		UE_LOG(LogTbSimpleNoSignalsInterfaceMsgBusClient, Error, TEXT("Client has no connection to service."));

		return;
	}

	auto msg = new FTbSimpleNoSignalsInterfaceFuncVoidRequestMessage();
	msg->RepsonseId = FGuid::NewGuid();

	if (TbSimpleNoSignalsInterfaceMsgBusEndpoint.IsValid())
	{

		TbSimpleNoSignalsInterfaceMsgBusEndpoint->Send<FTbSimpleNoSignalsInterfaceFuncVoidRequestMessage>(msg, EMessageFlags::Reliable,
			nullptr,
			TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
			FTimespan::Zero(),
			FDateTime::MaxValue());

		return;
	}

	return;
}

bool UTbSimpleNoSignalsInterfaceMsgBusClient::FuncBool_Implementation(bool bInParamBool)
{
	if (!IsConnected())
	{
		UE_LOG(LogTbSimpleNoSignalsInterfaceMsgBusClient, Error, TEXT("Client has no connection to service."));

		return false;
	}

	auto msg = new FTbSimpleNoSignalsInterfaceFuncBoolRequestMessage();
	msg->RepsonseId = FGuid::NewGuid();
	msg->bParamBool = bInParamBool;

	if (TbSimpleNoSignalsInterfaceMsgBusEndpoint.IsValid())
	{
		TPromise<bool> Promise;
		StorePromise(msg->RepsonseId, Promise);

		TbSimpleNoSignalsInterfaceMsgBusEndpoint->Send<FTbSimpleNoSignalsInterfaceFuncBoolRequestMessage>(msg, EMessageFlags::Reliable,
			nullptr,
			TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
			FTimespan::Zero(),
			FDateTime::MaxValue());

		return Promise.GetFuture().Get();
	}

	return false;
}

void UTbSimpleNoSignalsInterfaceMsgBusClient::OnFuncBoolReply(const FTbSimpleNoSignalsInterfaceFuncBoolReplyMessage& InFuncBoolReplyMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	FulfillPromise(InFuncBoolReplyMessage.RepsonseId, InFuncBoolReplyMessage.Result);
}

void UTbSimpleNoSignalsInterfaceMsgBusClient::OnPropBoolChanged(const FTbSimpleNoSignalsInterfacePropBoolChangedMessage& bInPropBoolMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogTbSimpleNoSignalsInterfaceMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	const bool bbPropBoolChanged = bInPropBoolMessage.bPropBool != bPropBool;
	if (bbPropBoolChanged)
	{
		bPropBool = bInPropBoolMessage.bPropBool;
		Execute__GetSignals(this)->OnPropBoolChanged.Broadcast(bPropBool);
	}
}

void UTbSimpleNoSignalsInterfaceMsgBusClient::OnPropIntChanged(const FTbSimpleNoSignalsInterfacePropIntChangedMessage& InPropIntMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogTbSimpleNoSignalsInterfaceMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	const bool bPropIntChanged = InPropIntMessage.PropInt != PropInt;
	if (bPropIntChanged)
	{
		PropInt = InPropIntMessage.PropInt;
		Execute__GetSignals(this)->OnPropIntChanged.Broadcast(PropInt);
	}
}

template <typename ResultType>
bool UTbSimpleNoSignalsInterfaceMsgBusClient::StorePromise(const FGuid& Id, TPromise<ResultType>& Promise)
{
	FScopeLock Lock(&ReplyPromisesMapCS);
	return ReplyPromisesMap.Add(Id, &Promise) != nullptr;
}

template <typename ResultType>
bool UTbSimpleNoSignalsInterfaceMsgBusClient::FulfillPromise(const FGuid& Id, const ResultType& Value)
{
	TPromise<ResultType>* PromisePtr = nullptr;

	{
		FScopeLock Lock(&ReplyPromisesMapCS);
		if (auto** Found = ReplyPromisesMap.Find(Id))
		{
			PromisePtr = static_cast<TPromise<ResultType>*>(*Found);
			ReplyPromisesMap.Remove(Id);
		}
	}

	if (PromisePtr)
	{
		PromisePtr->SetValue(Value);
		return true;
	}
	return false;
}

template bool UTbSimpleNoSignalsInterfaceMsgBusClient::StorePromise<bool>(const FGuid& Id, TPromise<bool>& Promise);
template bool UTbSimpleNoSignalsInterfaceMsgBusClient::FulfillPromise<bool>(const FGuid& Id, const bool& Value);
