/**
Copyright 2021 ApiGear UG
Copyright 2021 Epic Games, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

////////////////////////////////
// WARNING AUTOGENERATED
// DO NOT MODIFY
///////////////////////////////

#include "Generated/MsgBus/TbSame2SameStruct2InterfaceMsgBusClient.h"
#include "Generated/MsgBus/TbSame2SameStruct2InterfaceMsgBusMessages.h"
#include "Async/Async.h"
#include "Engine/World.h"
#include "TimerManager.h"
#include "Misc/DateTime.h"
#include "GenericPlatform/GenericPlatformMath.h"
#include "GenericPlatform/GenericPlatformTime.h"
#include "MessageEndpointBuilder.h"
#include "MessageEndpoint.h"
#include "TbSame2Settings.h"
#include "HAL/CriticalSection.h"

/**
   \brief data structure to hold the last sent property values
*/
struct TbSame2SameStruct2InterfacePropertiesMsgBusData
{
	FCriticalSection Prop1Mutex;
	FTbSame2Struct2 Prop1{FTbSame2Struct2()};
	FCriticalSection Prop2Mutex;
	FTbSame2Struct2 Prop2{FTbSame2Struct2()};
};
DEFINE_LOG_CATEGORY(LogTbSame2SameStruct2InterfaceMsgBusClient);

UTbSame2SameStruct2InterfaceMsgBusClient::UTbSame2SameStruct2InterfaceMsgBusClient()
	: UAbstractTbSame2SameStruct2Interface()
	, _SentData(MakePimpl<TbSame2SameStruct2InterfacePropertiesMsgBusData>())
{
	PingRTTBuffer.SetNumZeroed(PING_RTT_BUFFER_SIZE);
}

UTbSame2SameStruct2InterfaceMsgBusClient::~UTbSame2SameStruct2InterfaceMsgBusClient() = default;

void UTbSame2SameStruct2InterfaceMsgBusClient::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);
}

void UTbSame2SameStruct2InterfaceMsgBusClient::Deinitialize()
{
	_Disconnect();

	Super::Deinitialize();
}

void UTbSame2SameStruct2InterfaceMsgBusClient::_Connect()
{
	if (!_HeartbeatTimerHandle.IsValid() && GetWorld())
	{
		UTbSame2Settings* settings = GetMutableDefault<UTbSame2Settings>();
		check(settings);
		_HeartbeatIntervalMS = settings->MsgBusHeartbeatIntervalMS;

		GetWorld()->GetTimerManager().SetTimer(_HeartbeatTimerHandle, this, &UTbSame2SameStruct2InterfaceMsgBusClient::_OnHeartbeat, _HeartbeatIntervalMS / 1000.0f, true);
	}

	if (_IsConnected())
	{
		UE_LOG(LogTbSame2SameStruct2InterfaceMsgBusClient, Log, TEXT("Already connected, cannot connect again."));
		return;
	}

	if (TbSame2SameStruct2InterfaceMsgBusEndpoint.IsValid() && !ServiceAddress.IsValid())
	{
		_DiscoverService();
		return;
	}

	// clang-format off
	TbSame2SameStruct2InterfaceMsgBusEndpoint = FMessageEndpoint::Builder("ApiGear/TbSame2/SameStruct2Interface/Client")
		.Handling<FTbSame2SameStruct2InterfaceInitMessage>(this, &UTbSame2SameStruct2InterfaceMsgBusClient::OnConnectionInit)
		.Handling<FTbSame2SameStruct2InterfacePongMessage>(this, &UTbSame2SameStruct2InterfaceMsgBusClient::OnPong)
		.Handling<FTbSame2SameStruct2InterfaceServiceDisconnectMessage>(this, &UTbSame2SameStruct2InterfaceMsgBusClient::OnServiceClosedConnection)
		.Handling<FTbSame2SameStruct2InterfaceSig1SignalMessage>(this, &UTbSame2SameStruct2InterfaceMsgBusClient::OnSig1)
		.Handling<FTbSame2SameStruct2InterfaceSig2SignalMessage>(this, &UTbSame2SameStruct2InterfaceMsgBusClient::OnSig2)
		.Handling<FTbSame2SameStruct2InterfaceProp1ChangedMessage>(this, &UTbSame2SameStruct2InterfaceMsgBusClient::OnProp1Changed)
		.Handling<FTbSame2SameStruct2InterfaceProp2ChangedMessage>(this, &UTbSame2SameStruct2InterfaceMsgBusClient::OnProp2Changed)
		.Handling<FTbSame2SameStruct2InterfaceFunc1ReplyMessage>(this, &UTbSame2SameStruct2InterfaceMsgBusClient::OnFunc1Reply)
		.Handling<FTbSame2SameStruct2InterfaceFunc2ReplyMessage>(this, &UTbSame2SameStruct2InterfaceMsgBusClient::OnFunc2Reply)
		.Build();
	// clang-format on

	_DiscoverService();
}

void UTbSame2SameStruct2InterfaceMsgBusClient::_Disconnect()
{
	_LastHbTimestamp = 0.0f;
	if (_HeartbeatTimerHandle.IsValid() && GetWorld())
	{
		GetWorld()->GetTimerManager().ClearTimer(_HeartbeatTimerHandle);
	}

	if (!_IsConnected())
	{
		return;
	}

	auto msg = new FTbSame2SameStruct2InterfaceClientDisconnectMessage();

	TbSame2SameStruct2InterfaceMsgBusEndpoint->Send<FTbSame2SameStruct2InterfaceClientDisconnectMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());

	TbSame2SameStruct2InterfaceMsgBusEndpoint.Reset();
	ServiceAddress.Invalidate();
	_ConnectionStatusChanged.Broadcast(false);
}

void UTbSame2SameStruct2InterfaceMsgBusClient::_DiscoverService()
{
	if (!TbSame2SameStruct2InterfaceMsgBusEndpoint.IsValid())
	{
		return;
	}

	auto msg = new FTbSame2SameStruct2InterfaceDiscoveryMessage();
	TbSame2SameStruct2InterfaceMsgBusEndpoint->Publish<FTbSame2SameStruct2InterfaceDiscoveryMessage>(msg);
}

bool UTbSame2SameStruct2InterfaceMsgBusClient::_IsConnected() const
{
	return TbSame2SameStruct2InterfaceMsgBusEndpoint.IsValid() && ServiceAddress.IsValid();
}

void UTbSame2SameStruct2InterfaceMsgBusClient::OnConnectionInit(const FTbSame2SameStruct2InterfaceInitMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress.IsValid())
	{
		UE_LOG(LogTbSame2SameStruct2InterfaceMsgBusClient, Warning,
			TEXT("Got a second init message. It usually means that there are several instances of the same service on the network.")
				TEXT(" This can cause connection mixups. Please make sure that there is only one instance of the service running on the network."));
		return;
	}

	ServiceAddress = Context->GetSender();
	// reset ping stats for a new connection
	PingRTTBuffer.Empty();
	PingRTTBuffer.SetNumZeroed(PING_RTT_BUFFER_SIZE);
	CurrentPingCounter = 0;
	Stats.CurrentRTT_MS = 0.0f;
	Stats.AverageRTT_MS = 0.0f;
	Stats.MaxRTT_MS = 0.0f;
	Stats.MinRTT_MS = 10000.0f;

	const bool b_ClientPingIntervalMSChanged = InMessage._ClientPingIntervalMS != _HeartbeatIntervalMS;
	if (b_ClientPingIntervalMSChanged)
	{
		_HeartbeatIntervalMS = InMessage._ClientPingIntervalMS;

		if (_HeartbeatTimerHandle.IsValid() && GetWorld())
		{
			GetWorld()->GetTimerManager().ClearTimer(_HeartbeatTimerHandle);
		}

		if (!_HeartbeatTimerHandle.IsValid() && GetWorld())
		{
			GetWorld()->GetTimerManager().SetTimer(_HeartbeatTimerHandle, this, &UTbSame2SameStruct2InterfaceMsgBusClient::_OnHeartbeat, _HeartbeatIntervalMS / 1000.0f, true);
		}
	}
	const bool bProp1Changed = InMessage.Prop1 != Prop1;
	if (bProp1Changed)
	{
		Prop1 = InMessage.Prop1;
		Execute__GetSignals(this)->OnProp1Changed.Broadcast(Prop1);
	}

	const bool bProp2Changed = InMessage.Prop2 != Prop2;
	if (bProp2Changed)
	{
		Prop2 = InMessage.Prop2;
		Execute__GetSignals(this)->OnProp2Changed.Broadcast(Prop2);
	}

	_ConnectionStatusChanged.Broadcast(true);
}

void UTbSame2SameStruct2InterfaceMsgBusClient::_OnHeartbeat()
{
	if (_LastHbTimestamp > 0.1)
	{
		const double DeltaMS = (FPlatformTime::Seconds() - _LastHbTimestamp) * 1000.0;

		if (DeltaMS > 2 * _HeartbeatIntervalMS)
		{
			// service seems to be dead or not responding - reset connection
			ServiceAddress.Invalidate();
			_LastHbTimestamp = 0.0;
			_ConnectionStatusChanged.Broadcast(false);
		}
	}

	if (!_IsConnected())
	{
		// only log warning message once a second
		if (FPlatformTime::Seconds() - _LastConnectionWarningTimestamp > 1.0)
		{
			UE_LOG(LogTbSame2SameStruct2InterfaceMsgBusClient, Warning, TEXT("Heartbeat failed. Client has no connection to service. Reconnecting ..."));
			_LastConnectionWarningTimestamp = FPlatformTime::Seconds();
		}

		_Connect();
		return;
	}

	auto msg = new FTbSame2SameStruct2InterfacePingMessage();
	msg->Timestamp = FPlatformTime::Seconds();

	TbSame2SameStruct2InterfaceMsgBusEndpoint->Send<FTbSame2SameStruct2InterfacePingMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());
}

float UTbSame2SameStruct2InterfaceMsgBusClient::_CalculateAverageRTT() const
{
	if (CurrentPingCounter == 0)
	{
		return 0.0f;
	}

	float TotalRTT = 0.0f;

	for (const float& RTT : PingRTTBuffer)
	{
		TotalRTT += RTT;
	}

	return CurrentPingCounter > 0 ? TotalRTT / CurrentPingCounter : 0.0f;
}

void UTbSame2SameStruct2InterfaceMsgBusClient::OnPong(const FTbSame2SameStruct2InterfacePongMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	_LastHbTimestamp = InMessage.Timestamp;

	const double Current = FPlatformTime::Seconds();
	const double DeltaMS = (Current - InMessage.Timestamp) * 1000.0f;

	Stats.CurrentRTT_MS = DeltaMS;
	if (CurrentPingCounter < PING_RTT_BUFFER_SIZE)
	{
		CurrentPingCounter++;
	}
	PingRTTBuffer.RemoveAt(0);
	PingRTTBuffer.Add(Stats.CurrentRTT_MS);
	Stats.AverageRTT_MS = _CalculateAverageRTT();
	Stats.MaxRTT_MS = FGenericPlatformMath::Max(Stats.MaxRTT_MS, Stats.CurrentRTT_MS);
	Stats.MinRTT_MS = FGenericPlatformMath::Min(Stats.MinRTT_MS, Stats.CurrentRTT_MS);

	_StatsUpdated.Broadcast(Stats);
}

const FTbSame2SameStruct2InterfaceStats& UTbSame2SameStruct2InterfaceMsgBusClient::_GetStats() const
{
	return Stats;
}

void UTbSame2SameStruct2InterfaceMsgBusClient::OnServiceClosedConnection(const FTbSame2SameStruct2InterfaceServiceDisconnectMessage& /*InMessage*/, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		return;
	}

	_LastHbTimestamp = 0.0;
	ServiceAddress.Invalidate();
	_ConnectionStatusChanged.Broadcast(false);
}

FTbSame2Struct2 UTbSame2SameStruct2InterfaceMsgBusClient::GetProp1_Implementation() const
{
	return Prop1;
}

void UTbSame2SameStruct2InterfaceMsgBusClient::SetProp1_Implementation(const FTbSame2Struct2& InProp1)
{
	if (!_IsConnected())
	{
		UE_LOG(LogTbSame2SameStruct2InterfaceMsgBusClient, Error, TEXT("Client has no connection to service."));
		return;
	}

	// only send change requests if the value changed -> reduce network load
	if (GetProp1_Implementation() == InProp1)
	{
		return;
	}

	// only send change requests if the value wasn't already sent -> reduce network load
	{
		FScopeLock Lock(&(_SentData->Prop1Mutex));
		if (_SentData->Prop1 == InProp1)
		{
			return;
		}
	}

	auto msg = new FTbSame2SameStruct2InterfaceSetProp1RequestMessage();
	msg->Prop1 = InProp1;

	TbSame2SameStruct2InterfaceMsgBusEndpoint->Send<FTbSame2SameStruct2InterfaceSetProp1RequestMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());
	FScopeLock Lock(&(_SentData->Prop1Mutex));
	_SentData->Prop1 = InProp1;
}

FTbSame2Struct2 UTbSame2SameStruct2InterfaceMsgBusClient::GetProp2_Implementation() const
{
	return Prop2;
}

void UTbSame2SameStruct2InterfaceMsgBusClient::SetProp2_Implementation(const FTbSame2Struct2& InProp2)
{
	if (!_IsConnected())
	{
		UE_LOG(LogTbSame2SameStruct2InterfaceMsgBusClient, Error, TEXT("Client has no connection to service."));
		return;
	}

	// only send change requests if the value changed -> reduce network load
	if (GetProp2_Implementation() == InProp2)
	{
		return;
	}

	// only send change requests if the value wasn't already sent -> reduce network load
	{
		FScopeLock Lock(&(_SentData->Prop2Mutex));
		if (_SentData->Prop2 == InProp2)
		{
			return;
		}
	}

	auto msg = new FTbSame2SameStruct2InterfaceSetProp2RequestMessage();
	msg->Prop2 = InProp2;

	TbSame2SameStruct2InterfaceMsgBusEndpoint->Send<FTbSame2SameStruct2InterfaceSetProp2RequestMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());
	FScopeLock Lock(&(_SentData->Prop2Mutex));
	_SentData->Prop2 = InProp2;
}

FTbSame2Struct1 UTbSame2SameStruct2InterfaceMsgBusClient::Func1_Implementation(const FTbSame2Struct1& InParam1)
{
	if (!_IsConnected())
	{
		UE_LOG(LogTbSame2SameStruct2InterfaceMsgBusClient, Error, TEXT("Client has no connection to service."));

		return FTbSame2Struct1();
	}

	auto msg = new FTbSame2SameStruct2InterfaceFunc1RequestMessage();
	msg->ResponseId = FGuid::NewGuid();
	msg->Param1 = InParam1;
	TPromise<FTbSame2Struct1> Promise;
	StorePromise(msg->ResponseId, Promise);

	TbSame2SameStruct2InterfaceMsgBusEndpoint->Send<FTbSame2SameStruct2InterfaceFunc1RequestMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());

	return Promise.GetFuture().Get();
}

void UTbSame2SameStruct2InterfaceMsgBusClient::OnFunc1Reply(const FTbSame2SameStruct2InterfaceFunc1ReplyMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	FulfillPromise(InMessage.ResponseId, InMessage.Result);
}

FTbSame2Struct1 UTbSame2SameStruct2InterfaceMsgBusClient::Func2_Implementation(const FTbSame2Struct1& InParam1, const FTbSame2Struct2& InParam2)
{
	if (!_IsConnected())
	{
		UE_LOG(LogTbSame2SameStruct2InterfaceMsgBusClient, Error, TEXT("Client has no connection to service."));

		return FTbSame2Struct1();
	}

	auto msg = new FTbSame2SameStruct2InterfaceFunc2RequestMessage();
	msg->ResponseId = FGuid::NewGuid();
	msg->Param1 = InParam1;
	msg->Param2 = InParam2;
	TPromise<FTbSame2Struct1> Promise;
	StorePromise(msg->ResponseId, Promise);

	TbSame2SameStruct2InterfaceMsgBusEndpoint->Send<FTbSame2SameStruct2InterfaceFunc2RequestMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());

	return Promise.GetFuture().Get();
}

void UTbSame2SameStruct2InterfaceMsgBusClient::OnFunc2Reply(const FTbSame2SameStruct2InterfaceFunc2ReplyMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	FulfillPromise(InMessage.ResponseId, InMessage.Result);
}

void UTbSame2SameStruct2InterfaceMsgBusClient::OnSig1(const FTbSame2SameStruct2InterfaceSig1SignalMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogTbSame2SameStruct2InterfaceMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	Execute__GetSignals(this)->OnSig1Signal.Broadcast(InMessage.Param1);
	return;
}

void UTbSame2SameStruct2InterfaceMsgBusClient::OnSig2(const FTbSame2SameStruct2InterfaceSig2SignalMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogTbSame2SameStruct2InterfaceMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	Execute__GetSignals(this)->OnSig2Signal.Broadcast(InMessage.Param1, InMessage.Param2);
	return;
}

void UTbSame2SameStruct2InterfaceMsgBusClient::OnProp1Changed(const FTbSame2SameStruct2InterfaceProp1ChangedMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogTbSame2SameStruct2InterfaceMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	const bool bProp1Changed = InMessage.Prop1 != Prop1;
	if (bProp1Changed)
	{
		Prop1 = InMessage.Prop1;
		Execute__GetSignals(this)->OnProp1Changed.Broadcast(Prop1);
	}
}

void UTbSame2SameStruct2InterfaceMsgBusClient::OnProp2Changed(const FTbSame2SameStruct2InterfaceProp2ChangedMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogTbSame2SameStruct2InterfaceMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	const bool bProp2Changed = InMessage.Prop2 != Prop2;
	if (bProp2Changed)
	{
		Prop2 = InMessage.Prop2;
		Execute__GetSignals(this)->OnProp2Changed.Broadcast(Prop2);
	}
}

template <typename ResultType>
bool UTbSame2SameStruct2InterfaceMsgBusClient::StorePromise(const FGuid& Id, TPromise<ResultType>& Promise)
{
	FScopeLock Lock(&ReplyPromisesMapCS);
	return ReplyPromisesMap.Add(Id, &Promise) != nullptr;
}

template <typename ResultType>
bool UTbSame2SameStruct2InterfaceMsgBusClient::FulfillPromise(const FGuid& Id, const ResultType& Value)
{
	TPromise<ResultType>* PromisePtr = nullptr;

	{
		FScopeLock Lock(&ReplyPromisesMapCS);
		if (auto** Found = ReplyPromisesMap.Find(Id))
		{
			PromisePtr = static_cast<TPromise<ResultType>*>(*Found);
			ReplyPromisesMap.Remove(Id);
		}
	}

	if (PromisePtr)
	{
		PromisePtr->SetValue(Value);
		return true;
	}
	return false;
}

template bool UTbSame2SameStruct2InterfaceMsgBusClient::StorePromise<FTbSame2Struct1>(const FGuid& Id, TPromise<FTbSame2Struct1>& Promise);
template bool UTbSame2SameStruct2InterfaceMsgBusClient::FulfillPromise<FTbSame2Struct1>(const FGuid& Id, const FTbSame2Struct1& Value);
