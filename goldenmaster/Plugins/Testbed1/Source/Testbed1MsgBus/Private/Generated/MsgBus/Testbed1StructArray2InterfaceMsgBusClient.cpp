/**
Copyright 2021 ApiGear UG
Copyright 2021 Epic Games, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

////////////////////////////////
// WARNING AUTOGENERATED
// DO NOT MODIFY
///////////////////////////////

#include "Testbed1/Generated/MsgBus/Testbed1StructArray2InterfaceMsgBusClient.h"
#include "Testbed1/Generated/MsgBus/Testbed1StructArray2InterfaceMsgBusMessages.h"
#include "Async/Async.h"
#include "Engine/Engine.h"
#include "TimerManager.h"
#include "Misc/DateTime.h"
#include "GenericPlatform/GenericPlatformMath.h"
#include "GenericPlatform/GenericPlatformTime.h"
#include "MessageEndpointBuilder.h"
#include "MessageEndpoint.h"
#include "HAL/CriticalSection.h"

/**
   \brief data structure to hold the last sent property values
*/
struct Testbed1StructArray2InterfacePropertiesMsgBusData
{
	FCriticalSection PropBoolMutex;
	FTestbed1StructBoolWithArray PropBool{FTestbed1StructBoolWithArray()};
	FCriticalSection PropIntMutex;
	FTestbed1StructIntWithArray PropInt{FTestbed1StructIntWithArray()};
	FCriticalSection PropFloatMutex;
	FTestbed1StructFloatWithArray PropFloat{FTestbed1StructFloatWithArray()};
	FCriticalSection PropStringMutex;
	FTestbed1StructStringWithArray PropString{FTestbed1StructStringWithArray()};
	FCriticalSection PropEnumMutex;
	FTestbed1StructEnumWithArray PropEnum{FTestbed1StructEnumWithArray()};
};
DEFINE_LOG_CATEGORY(LogTestbed1StructArray2InterfaceMsgBusClient);

UTestbed1StructArray2InterfaceMsgBusClient::UTestbed1StructArray2InterfaceMsgBusClient()
	: UAbstractTestbed1StructArray2Interface()
	, _SentData(MakePimpl<Testbed1StructArray2InterfacePropertiesMsgBusData>())
{
	PingRTTBuffer.SetNumZeroed(PING_RTT_BUFFER_SIZE);
}

UTestbed1StructArray2InterfaceMsgBusClient::~UTestbed1StructArray2InterfaceMsgBusClient() = default;

void UTestbed1StructArray2InterfaceMsgBusClient::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);
}

void UTestbed1StructArray2InterfaceMsgBusClient::Deinitialize()
{
	_Disconnect();

	Super::Deinitialize();
}

void UTestbed1StructArray2InterfaceMsgBusClient::_Connect()
{
	if (!_HeartbeatTimerHandle.IsValid() && GetWorld())
	{
		GetWorld()->GetTimerManager().SetTimer(_HeartbeatTimerHandle, this, &UTestbed1StructArray2InterfaceMsgBusClient::_OnHeartbeat, _HeartbeatIntervalMS / 1000.0f, true);
	}

	if (_IsConnected())
	{
		UE_LOG(LogTestbed1StructArray2InterfaceMsgBusClient, Log, TEXT("Already connected, cannot connect again."));
		return;
	}

	if (Testbed1StructArray2InterfaceMsgBusEndpoint.IsValid() && !ServiceAddress.IsValid())
	{
		_DiscoverService();
		return;
	}

	// clang-format off
	Testbed1StructArray2InterfaceMsgBusEndpoint = FMessageEndpoint::Builder("ApiGear/Testbed1/StructArray2Interface/Client")
		.Handling<FTestbed1StructArray2InterfaceInitMessage>(this, &UTestbed1StructArray2InterfaceMsgBusClient::OnConnectionInit)
		.Handling<FTestbed1StructArray2InterfacePongMessage>(this, &UTestbed1StructArray2InterfaceMsgBusClient::OnPong)
		.Handling<FTestbed1StructArray2InterfaceServiceDisconnectMessage>(this, &UTestbed1StructArray2InterfaceMsgBusClient::OnServiceClosedConnection)
		.Handling<FTestbed1StructArray2InterfaceSigBoolSignalMessage>(this, &UTestbed1StructArray2InterfaceMsgBusClient::OnSigBool)
		.Handling<FTestbed1StructArray2InterfaceSigIntSignalMessage>(this, &UTestbed1StructArray2InterfaceMsgBusClient::OnSigInt)
		.Handling<FTestbed1StructArray2InterfaceSigFloatSignalMessage>(this, &UTestbed1StructArray2InterfaceMsgBusClient::OnSigFloat)
		.Handling<FTestbed1StructArray2InterfaceSigStringSignalMessage>(this, &UTestbed1StructArray2InterfaceMsgBusClient::OnSigString)
		.Handling<FTestbed1StructArray2InterfacePropBoolChangedMessage>(this, &UTestbed1StructArray2InterfaceMsgBusClient::OnPropBoolChanged)
		.Handling<FTestbed1StructArray2InterfacePropIntChangedMessage>(this, &UTestbed1StructArray2InterfaceMsgBusClient::OnPropIntChanged)
		.Handling<FTestbed1StructArray2InterfacePropFloatChangedMessage>(this, &UTestbed1StructArray2InterfaceMsgBusClient::OnPropFloatChanged)
		.Handling<FTestbed1StructArray2InterfacePropStringChangedMessage>(this, &UTestbed1StructArray2InterfaceMsgBusClient::OnPropStringChanged)
		.Handling<FTestbed1StructArray2InterfacePropEnumChangedMessage>(this, &UTestbed1StructArray2InterfaceMsgBusClient::OnPropEnumChanged)
		.Handling<FTestbed1StructArray2InterfaceFuncBoolReplyMessage>(this, &UTestbed1StructArray2InterfaceMsgBusClient::OnFuncBoolReply)
		.Handling<FTestbed1StructArray2InterfaceFuncIntReplyMessage>(this, &UTestbed1StructArray2InterfaceMsgBusClient::OnFuncIntReply)
		.Handling<FTestbed1StructArray2InterfaceFuncFloatReplyMessage>(this, &UTestbed1StructArray2InterfaceMsgBusClient::OnFuncFloatReply)
		.Handling<FTestbed1StructArray2InterfaceFuncStringReplyMessage>(this, &UTestbed1StructArray2InterfaceMsgBusClient::OnFuncStringReply)
		.Handling<FTestbed1StructArray2InterfaceFuncEnumReplyMessage>(this, &UTestbed1StructArray2InterfaceMsgBusClient::OnFuncEnumReply)
		.Build();
	// clang-format on

	_DiscoverService();
}

void UTestbed1StructArray2InterfaceMsgBusClient::_Disconnect()
{
	_LastHbTimestamp = 0.0f;
	if (_HeartbeatTimerHandle.IsValid() && GetWorld())
	{
		GetWorld()->GetTimerManager().ClearTimer(_HeartbeatTimerHandle);
	}

	if (!_IsConnected())
	{
		return;
	}

	auto msg = new FTestbed1StructArray2InterfaceClientDisconnectMessage();

	Testbed1StructArray2InterfaceMsgBusEndpoint->Send<FTestbed1StructArray2InterfaceClientDisconnectMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());

	Testbed1StructArray2InterfaceMsgBusEndpoint.Reset();
	ServiceAddress.Invalidate();
	_ConnectionStatusChanged.Broadcast(false);
	_ConnectionStatusChangedBP.Broadcast(false);
}

void UTestbed1StructArray2InterfaceMsgBusClient::_DiscoverService()
{
	if (!Testbed1StructArray2InterfaceMsgBusEndpoint.IsValid())
	{
		return;
	}

	auto msg = new FTestbed1StructArray2InterfaceDiscoveryMessage();
	Testbed1StructArray2InterfaceMsgBusEndpoint->Publish<FTestbed1StructArray2InterfaceDiscoveryMessage>(msg);
}

bool UTestbed1StructArray2InterfaceMsgBusClient::_IsConnected() const
{
	return Testbed1StructArray2InterfaceMsgBusEndpoint.IsValid() && ServiceAddress.IsValid();
}

void UTestbed1StructArray2InterfaceMsgBusClient::OnConnectionInit(const FTestbed1StructArray2InterfaceInitMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress.IsValid())
	{
		UE_LOG(LogTestbed1StructArray2InterfaceMsgBusClient, Warning,
			TEXT("Got a second init message. It usually means that there are several instances of the same service on the network.")
				TEXT(" This can cause connection mixups. Please make sure that there is only one instance of the service running on the network."));
		return;
	}

	ServiceAddress = Context->GetSender();
	// reset ping stats for a new connection
	PingRTTBuffer.Empty();
	PingRTTBuffer.SetNumZeroed(PING_RTT_BUFFER_SIZE);
	CurrentPingCounter = 0;
	Stats.CurrentRTT_MS = 0.0f;
	Stats.AverageRTT_MS = 0.0f;
	Stats.MaxRTT_MS = 0.0f;
	Stats.MinRTT_MS = 10000.0f;

	const bool b_ClientPingIntervalMSChanged = InMessage._ClientPingIntervalMS != _HeartbeatIntervalMS;
	if (b_ClientPingIntervalMSChanged)
	{
		_HeartbeatIntervalMS = InMessage._ClientPingIntervalMS;

		if (_HeartbeatTimerHandle.IsValid() && GetWorld())
		{
			GetWorld()->GetTimerManager().ClearTimer(_HeartbeatTimerHandle);
		}

		if (!_HeartbeatTimerHandle.IsValid() && GetWorld())
		{
			GetWorld()->GetTimerManager().SetTimer(_HeartbeatTimerHandle, this, &UTestbed1StructArray2InterfaceMsgBusClient::_OnHeartbeat, _HeartbeatIntervalMS / 1000.0f, true);
		}
	}
	const bool bPropBoolChanged = InMessage.PropBool != PropBool;
	if (bPropBoolChanged)
	{
		PropBool = InMessage.PropBool;
		_GetSignals()->BroadcastPropBoolChanged(PropBool);
	}

	const bool bPropIntChanged = InMessage.PropInt != PropInt;
	if (bPropIntChanged)
	{
		PropInt = InMessage.PropInt;
		_GetSignals()->BroadcastPropIntChanged(PropInt);
	}

	const bool bPropFloatChanged = InMessage.PropFloat != PropFloat;
	if (bPropFloatChanged)
	{
		PropFloat = InMessage.PropFloat;
		_GetSignals()->BroadcastPropFloatChanged(PropFloat);
	}

	const bool bPropStringChanged = InMessage.PropString != PropString;
	if (bPropStringChanged)
	{
		PropString = InMessage.PropString;
		_GetSignals()->BroadcastPropStringChanged(PropString);
	}

	const bool bPropEnumChanged = InMessage.PropEnum != PropEnum;
	if (bPropEnumChanged)
	{
		PropEnum = InMessage.PropEnum;
		_GetSignals()->BroadcastPropEnumChanged(PropEnum);
	}

	_ConnectionStatusChanged.Broadcast(true);
	_ConnectionStatusChangedBP.Broadcast(true);
}

void UTestbed1StructArray2InterfaceMsgBusClient::_OnHeartbeat()
{
	if (_LastHbTimestamp > 0.1)
	{
		const double DeltaMS = (FPlatformTime::Seconds() - _LastHbTimestamp) * 1000.0;

		if (DeltaMS > 2 * _HeartbeatIntervalMS)
		{
			// service seems to be dead or not responding - reset connection
			ServiceAddress.Invalidate();
			_LastHbTimestamp = 0.0;
			_ConnectionStatusChanged.Broadcast(false);
		}
	}

	if (!_IsConnected())
	{
		// only log warning message once a second
		if (FPlatformTime::Seconds() - _LastConnectionWarningTimestamp > 1.0)
		{
			UE_LOG(LogTestbed1StructArray2InterfaceMsgBusClient, Warning, TEXT("Heartbeat failed. Client has no connection to service. Reconnecting ..."));
			_LastConnectionWarningTimestamp = FPlatformTime::Seconds();
		}

		_Connect();
		return;
	}

	auto msg = new FTestbed1StructArray2InterfacePingMessage();
	msg->Timestamp = FPlatformTime::Seconds();

	Testbed1StructArray2InterfaceMsgBusEndpoint->Send<FTestbed1StructArray2InterfacePingMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());
}

float UTestbed1StructArray2InterfaceMsgBusClient::_CalculateAverageRTT() const
{
	if (CurrentPingCounter == 0)
	{
		return 0.0f;
	}

	float TotalRTT = 0.0f;

	for (const float& RTT : PingRTTBuffer)
	{
		TotalRTT += RTT;
	}

	return CurrentPingCounter > 0 ? TotalRTT / CurrentPingCounter : 0.0f;
}

void UTestbed1StructArray2InterfaceMsgBusClient::OnPong(const FTestbed1StructArray2InterfacePongMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	_LastHbTimestamp = InMessage.Timestamp;

	const double Current = FPlatformTime::Seconds();
	const double DeltaMS = (Current - InMessage.Timestamp) * 1000.0f;

	Stats.CurrentRTT_MS = DeltaMS;
	if (CurrentPingCounter < PING_RTT_BUFFER_SIZE)
	{
		CurrentPingCounter++;
	}
	PingRTTBuffer.RemoveAt(0);
	PingRTTBuffer.Add(Stats.CurrentRTT_MS);
	Stats.AverageRTT_MS = _CalculateAverageRTT();
	Stats.MaxRTT_MS = FGenericPlatformMath::Max(Stats.MaxRTT_MS, Stats.CurrentRTT_MS);
	Stats.MinRTT_MS = FGenericPlatformMath::Min(Stats.MinRTT_MS, Stats.CurrentRTT_MS);

	_StatsUpdated.Broadcast(Stats);
}

const FTestbed1StructArray2InterfaceStats& UTestbed1StructArray2InterfaceMsgBusClient::_GetStats() const
{
	return Stats;
}

void UTestbed1StructArray2InterfaceMsgBusClient::OnServiceClosedConnection(const FTestbed1StructArray2InterfaceServiceDisconnectMessage& /*InMessage*/, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		return;
	}

	_LastHbTimestamp = 0.0;
	ServiceAddress.Invalidate();
	_ConnectionStatusChanged.Broadcast(false);
	_ConnectionStatusChangedBP.Broadcast(false);
}

FTestbed1StructBoolWithArray UTestbed1StructArray2InterfaceMsgBusClient::GetPropBool() const
{
	return PropBool;
}

void UTestbed1StructArray2InterfaceMsgBusClient::SetPropBool(const FTestbed1StructBoolWithArray& InPropBool)
{
	if (!_IsConnected())
	{
		UE_LOG(LogTestbed1StructArray2InterfaceMsgBusClient, Error, TEXT("Client has no connection to service."));
		return;
	}

	// only send change requests if the value changed -> reduce network load
	if (GetPropBool() == InPropBool)
	{
		return;
	}

	// only send change requests if the value wasn't already sent -> reduce network load
	{
		FScopeLock Lock(&(_SentData->PropBoolMutex));
		if (_SentData->PropBool == InPropBool)
		{
			return;
		}
	}

	auto msg = new FTestbed1StructArray2InterfaceSetPropBoolRequestMessage();
	msg->PropBool = InPropBool;

	Testbed1StructArray2InterfaceMsgBusEndpoint->Send<FTestbed1StructArray2InterfaceSetPropBoolRequestMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());
	FScopeLock Lock(&(_SentData->PropBoolMutex));
	_SentData->PropBool = InPropBool;
}

FTestbed1StructIntWithArray UTestbed1StructArray2InterfaceMsgBusClient::GetPropInt() const
{
	return PropInt;
}

void UTestbed1StructArray2InterfaceMsgBusClient::SetPropInt(const FTestbed1StructIntWithArray& InPropInt)
{
	if (!_IsConnected())
	{
		UE_LOG(LogTestbed1StructArray2InterfaceMsgBusClient, Error, TEXT("Client has no connection to service."));
		return;
	}

	// only send change requests if the value changed -> reduce network load
	if (GetPropInt() == InPropInt)
	{
		return;
	}

	// only send change requests if the value wasn't already sent -> reduce network load
	{
		FScopeLock Lock(&(_SentData->PropIntMutex));
		if (_SentData->PropInt == InPropInt)
		{
			return;
		}
	}

	auto msg = new FTestbed1StructArray2InterfaceSetPropIntRequestMessage();
	msg->PropInt = InPropInt;

	Testbed1StructArray2InterfaceMsgBusEndpoint->Send<FTestbed1StructArray2InterfaceSetPropIntRequestMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());
	FScopeLock Lock(&(_SentData->PropIntMutex));
	_SentData->PropInt = InPropInt;
}

FTestbed1StructFloatWithArray UTestbed1StructArray2InterfaceMsgBusClient::GetPropFloat() const
{
	return PropFloat;
}

void UTestbed1StructArray2InterfaceMsgBusClient::SetPropFloat(const FTestbed1StructFloatWithArray& InPropFloat)
{
	if (!_IsConnected())
	{
		UE_LOG(LogTestbed1StructArray2InterfaceMsgBusClient, Error, TEXT("Client has no connection to service."));
		return;
	}

	// only send change requests if the value changed -> reduce network load
	if (GetPropFloat() == InPropFloat)
	{
		return;
	}

	// only send change requests if the value wasn't already sent -> reduce network load
	{
		FScopeLock Lock(&(_SentData->PropFloatMutex));
		if (_SentData->PropFloat == InPropFloat)
		{
			return;
		}
	}

	auto msg = new FTestbed1StructArray2InterfaceSetPropFloatRequestMessage();
	msg->PropFloat = InPropFloat;

	Testbed1StructArray2InterfaceMsgBusEndpoint->Send<FTestbed1StructArray2InterfaceSetPropFloatRequestMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());
	FScopeLock Lock(&(_SentData->PropFloatMutex));
	_SentData->PropFloat = InPropFloat;
}

FTestbed1StructStringWithArray UTestbed1StructArray2InterfaceMsgBusClient::GetPropString() const
{
	return PropString;
}

void UTestbed1StructArray2InterfaceMsgBusClient::SetPropString(const FTestbed1StructStringWithArray& InPropString)
{
	if (!_IsConnected())
	{
		UE_LOG(LogTestbed1StructArray2InterfaceMsgBusClient, Error, TEXT("Client has no connection to service."));
		return;
	}

	// only send change requests if the value changed -> reduce network load
	if (GetPropString() == InPropString)
	{
		return;
	}

	// only send change requests if the value wasn't already sent -> reduce network load
	{
		FScopeLock Lock(&(_SentData->PropStringMutex));
		if (_SentData->PropString == InPropString)
		{
			return;
		}
	}

	auto msg = new FTestbed1StructArray2InterfaceSetPropStringRequestMessage();
	msg->PropString = InPropString;

	Testbed1StructArray2InterfaceMsgBusEndpoint->Send<FTestbed1StructArray2InterfaceSetPropStringRequestMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());
	FScopeLock Lock(&(_SentData->PropStringMutex));
	_SentData->PropString = InPropString;
}

FTestbed1StructEnumWithArray UTestbed1StructArray2InterfaceMsgBusClient::GetPropEnum() const
{
	return PropEnum;
}

void UTestbed1StructArray2InterfaceMsgBusClient::SetPropEnum(const FTestbed1StructEnumWithArray& InPropEnum)
{
	if (!_IsConnected())
	{
		UE_LOG(LogTestbed1StructArray2InterfaceMsgBusClient, Error, TEXT("Client has no connection to service."));
		return;
	}

	// only send change requests if the value changed -> reduce network load
	if (GetPropEnum() == InPropEnum)
	{
		return;
	}

	// only send change requests if the value wasn't already sent -> reduce network load
	{
		FScopeLock Lock(&(_SentData->PropEnumMutex));
		if (_SentData->PropEnum == InPropEnum)
		{
			return;
		}
	}

	auto msg = new FTestbed1StructArray2InterfaceSetPropEnumRequestMessage();
	msg->PropEnum = InPropEnum;

	Testbed1StructArray2InterfaceMsgBusEndpoint->Send<FTestbed1StructArray2InterfaceSetPropEnumRequestMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());
	FScopeLock Lock(&(_SentData->PropEnumMutex));
	_SentData->PropEnum = InPropEnum;
}

TArray<FTestbed1StructBool> UTestbed1StructArray2InterfaceMsgBusClient::FuncBool(const FTestbed1StructBoolWithArray& InParamBool)
{
	if (!_IsConnected())
	{
		UE_LOG(LogTestbed1StructArray2InterfaceMsgBusClient, Error, TEXT("Client has no connection to service."));

		return TArray<FTestbed1StructBool>();
	}

	auto msg = new FTestbed1StructArray2InterfaceFuncBoolRequestMessage();
	msg->ResponseId = FGuid::NewGuid();
	msg->ParamBool = InParamBool;
	TPromise<TArray<FTestbed1StructBool>> Promise;
	StorePromise(msg->ResponseId, Promise);

	Testbed1StructArray2InterfaceMsgBusEndpoint->Send<FTestbed1StructArray2InterfaceFuncBoolRequestMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());

	return Promise.GetFuture().Get();
}

void UTestbed1StructArray2InterfaceMsgBusClient::OnFuncBoolReply(const FTestbed1StructArray2InterfaceFuncBoolReplyMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	FulfillPromise(InMessage.ResponseId, InMessage.Result);
}

TArray<FTestbed1StructInt> UTestbed1StructArray2InterfaceMsgBusClient::FuncInt(const FTestbed1StructIntWithArray& InParamInt)
{
	if (!_IsConnected())
	{
		UE_LOG(LogTestbed1StructArray2InterfaceMsgBusClient, Error, TEXT("Client has no connection to service."));

		return TArray<FTestbed1StructInt>();
	}

	auto msg = new FTestbed1StructArray2InterfaceFuncIntRequestMessage();
	msg->ResponseId = FGuid::NewGuid();
	msg->ParamInt = InParamInt;
	TPromise<TArray<FTestbed1StructInt>> Promise;
	StorePromise(msg->ResponseId, Promise);

	Testbed1StructArray2InterfaceMsgBusEndpoint->Send<FTestbed1StructArray2InterfaceFuncIntRequestMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());

	return Promise.GetFuture().Get();
}

void UTestbed1StructArray2InterfaceMsgBusClient::OnFuncIntReply(const FTestbed1StructArray2InterfaceFuncIntReplyMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	FulfillPromise(InMessage.ResponseId, InMessage.Result);
}

TArray<FTestbed1StructFloat> UTestbed1StructArray2InterfaceMsgBusClient::FuncFloat(const FTestbed1StructFloatWithArray& InParamFloat)
{
	if (!_IsConnected())
	{
		UE_LOG(LogTestbed1StructArray2InterfaceMsgBusClient, Error, TEXT("Client has no connection to service."));

		return TArray<FTestbed1StructFloat>();
	}

	auto msg = new FTestbed1StructArray2InterfaceFuncFloatRequestMessage();
	msg->ResponseId = FGuid::NewGuid();
	msg->ParamFloat = InParamFloat;
	TPromise<TArray<FTestbed1StructFloat>> Promise;
	StorePromise(msg->ResponseId, Promise);

	Testbed1StructArray2InterfaceMsgBusEndpoint->Send<FTestbed1StructArray2InterfaceFuncFloatRequestMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());

	return Promise.GetFuture().Get();
}

void UTestbed1StructArray2InterfaceMsgBusClient::OnFuncFloatReply(const FTestbed1StructArray2InterfaceFuncFloatReplyMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	FulfillPromise(InMessage.ResponseId, InMessage.Result);
}

TArray<FTestbed1StructString> UTestbed1StructArray2InterfaceMsgBusClient::FuncString(const FTestbed1StructStringWithArray& InParamString)
{
	if (!_IsConnected())
	{
		UE_LOG(LogTestbed1StructArray2InterfaceMsgBusClient, Error, TEXT("Client has no connection to service."));

		return TArray<FTestbed1StructString>();
	}

	auto msg = new FTestbed1StructArray2InterfaceFuncStringRequestMessage();
	msg->ResponseId = FGuid::NewGuid();
	msg->ParamString = InParamString;
	TPromise<TArray<FTestbed1StructString>> Promise;
	StorePromise(msg->ResponseId, Promise);

	Testbed1StructArray2InterfaceMsgBusEndpoint->Send<FTestbed1StructArray2InterfaceFuncStringRequestMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());

	return Promise.GetFuture().Get();
}

void UTestbed1StructArray2InterfaceMsgBusClient::OnFuncStringReply(const FTestbed1StructArray2InterfaceFuncStringReplyMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	FulfillPromise(InMessage.ResponseId, InMessage.Result);
}

TArray<ETestbed1Enum0> UTestbed1StructArray2InterfaceMsgBusClient::FuncEnum(const FTestbed1StructEnumWithArray& InParamEnum)
{
	if (!_IsConnected())
	{
		UE_LOG(LogTestbed1StructArray2InterfaceMsgBusClient, Error, TEXT("Client has no connection to service."));

		return TArray<ETestbed1Enum0>();
	}

	auto msg = new FTestbed1StructArray2InterfaceFuncEnumRequestMessage();
	msg->ResponseId = FGuid::NewGuid();
	msg->ParamEnum = InParamEnum;
	TPromise<TArray<ETestbed1Enum0>> Promise;
	StorePromise(msg->ResponseId, Promise);

	Testbed1StructArray2InterfaceMsgBusEndpoint->Send<FTestbed1StructArray2InterfaceFuncEnumRequestMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());

	return Promise.GetFuture().Get();
}

void UTestbed1StructArray2InterfaceMsgBusClient::OnFuncEnumReply(const FTestbed1StructArray2InterfaceFuncEnumReplyMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	FulfillPromise(InMessage.ResponseId, InMessage.Result);
}

void UTestbed1StructArray2InterfaceMsgBusClient::OnSigBool(const FTestbed1StructArray2InterfaceSigBoolSignalMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogTestbed1StructArray2InterfaceMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	_GetSignals()->BroadcastSigBoolSignal(InMessage.ParamBool);
	return;
}

void UTestbed1StructArray2InterfaceMsgBusClient::OnSigInt(const FTestbed1StructArray2InterfaceSigIntSignalMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogTestbed1StructArray2InterfaceMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	_GetSignals()->BroadcastSigIntSignal(InMessage.ParamInt);
	return;
}

void UTestbed1StructArray2InterfaceMsgBusClient::OnSigFloat(const FTestbed1StructArray2InterfaceSigFloatSignalMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogTestbed1StructArray2InterfaceMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	_GetSignals()->BroadcastSigFloatSignal(InMessage.ParamFloat);
	return;
}

void UTestbed1StructArray2InterfaceMsgBusClient::OnSigString(const FTestbed1StructArray2InterfaceSigStringSignalMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogTestbed1StructArray2InterfaceMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	_GetSignals()->BroadcastSigStringSignal(InMessage.ParamString);
	return;
}

void UTestbed1StructArray2InterfaceMsgBusClient::OnPropBoolChanged(const FTestbed1StructArray2InterfacePropBoolChangedMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogTestbed1StructArray2InterfaceMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	const bool bPropBoolChanged = InMessage.PropBool != PropBool;
	if (bPropBoolChanged)
	{
		PropBool = InMessage.PropBool;
		_GetSignals()->BroadcastPropBoolChanged(PropBool);
	}
}

void UTestbed1StructArray2InterfaceMsgBusClient::OnPropIntChanged(const FTestbed1StructArray2InterfacePropIntChangedMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogTestbed1StructArray2InterfaceMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	const bool bPropIntChanged = InMessage.PropInt != PropInt;
	if (bPropIntChanged)
	{
		PropInt = InMessage.PropInt;
		_GetSignals()->BroadcastPropIntChanged(PropInt);
	}
}

void UTestbed1StructArray2InterfaceMsgBusClient::OnPropFloatChanged(const FTestbed1StructArray2InterfacePropFloatChangedMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogTestbed1StructArray2InterfaceMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	const bool bPropFloatChanged = InMessage.PropFloat != PropFloat;
	if (bPropFloatChanged)
	{
		PropFloat = InMessage.PropFloat;
		_GetSignals()->BroadcastPropFloatChanged(PropFloat);
	}
}

void UTestbed1StructArray2InterfaceMsgBusClient::OnPropStringChanged(const FTestbed1StructArray2InterfacePropStringChangedMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogTestbed1StructArray2InterfaceMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	const bool bPropStringChanged = InMessage.PropString != PropString;
	if (bPropStringChanged)
	{
		PropString = InMessage.PropString;
		_GetSignals()->BroadcastPropStringChanged(PropString);
	}
}

void UTestbed1StructArray2InterfaceMsgBusClient::OnPropEnumChanged(const FTestbed1StructArray2InterfacePropEnumChangedMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogTestbed1StructArray2InterfaceMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	const bool bPropEnumChanged = InMessage.PropEnum != PropEnum;
	if (bPropEnumChanged)
	{
		PropEnum = InMessage.PropEnum;
		_GetSignals()->BroadcastPropEnumChanged(PropEnum);
	}
}

template <typename ResultType>
bool UTestbed1StructArray2InterfaceMsgBusClient::StorePromise(const FGuid& Id, TPromise<ResultType>& Promise)
{
	FScopeLock Lock(&ReplyPromisesMapCS);
	return ReplyPromisesMap.Add(Id, &Promise) != nullptr;
}

template <typename ResultType>
bool UTestbed1StructArray2InterfaceMsgBusClient::FulfillPromise(const FGuid& Id, const ResultType& Value)
{
	TPromise<ResultType>* PromisePtr = nullptr;

	{
		FScopeLock Lock(&ReplyPromisesMapCS);
		if (auto** Found = ReplyPromisesMap.Find(Id))
		{
			PromisePtr = static_cast<TPromise<ResultType>*>(*Found);
			ReplyPromisesMap.Remove(Id);
		}
	}

	if (PromisePtr)
	{
		PromisePtr->SetValue(Value);
		return true;
	}
	return false;
}

template bool UTestbed1StructArray2InterfaceMsgBusClient::StorePromise<TArray<ETestbed1Enum0>>(const FGuid& Id, TPromise<TArray<ETestbed1Enum0>>& Promise);
template bool UTestbed1StructArray2InterfaceMsgBusClient::FulfillPromise<TArray<ETestbed1Enum0>>(const FGuid& Id, const TArray<ETestbed1Enum0>& Value);
template bool UTestbed1StructArray2InterfaceMsgBusClient::StorePromise<TArray<FTestbed1StructBool>>(const FGuid& Id, TPromise<TArray<FTestbed1StructBool>>& Promise);
template bool UTestbed1StructArray2InterfaceMsgBusClient::FulfillPromise<TArray<FTestbed1StructBool>>(const FGuid& Id, const TArray<FTestbed1StructBool>& Value);
template bool UTestbed1StructArray2InterfaceMsgBusClient::StorePromise<TArray<FTestbed1StructFloat>>(const FGuid& Id, TPromise<TArray<FTestbed1StructFloat>>& Promise);
template bool UTestbed1StructArray2InterfaceMsgBusClient::FulfillPromise<TArray<FTestbed1StructFloat>>(const FGuid& Id, const TArray<FTestbed1StructFloat>& Value);
template bool UTestbed1StructArray2InterfaceMsgBusClient::StorePromise<TArray<FTestbed1StructInt>>(const FGuid& Id, TPromise<TArray<FTestbed1StructInt>>& Promise);
template bool UTestbed1StructArray2InterfaceMsgBusClient::FulfillPromise<TArray<FTestbed1StructInt>>(const FGuid& Id, const TArray<FTestbed1StructInt>& Value);
template bool UTestbed1StructArray2InterfaceMsgBusClient::StorePromise<TArray<FTestbed1StructString>>(const FGuid& Id, TPromise<TArray<FTestbed1StructString>>& Promise);
template bool UTestbed1StructArray2InterfaceMsgBusClient::FulfillPromise<TArray<FTestbed1StructString>>(const FGuid& Id, const TArray<FTestbed1StructString>& Value);
