/**
Copyright 2021 ApiGear UG
Copyright 2021 Epic Games, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

////////////////////////////////
// WARNING AUTOGENERATED
// DO NOT MODIFY
///////////////////////////////

#include "Generated/MsgBus/Testbed2NestedStruct3InterfaceMsgBusClient.h"
#include "Generated/MsgBus/Testbed2NestedStruct3InterfaceMsgBusMessages.h"
#include "Async/Async.h"
#include "Engine/Engine.h"
#include "Misc/DateTime.h"
#include "MessageEndpointBuilder.h"
#include "MessageEndpoint.h"
#include "HAL/CriticalSection.h"

/**
   \brief data structure to hold the last sent property values
*/
struct Testbed2NestedStruct3InterfacePropertiesMsgBusData
{
	FCriticalSection Prop1Mutex;
	FTestbed2NestedStruct1 Prop1{FTestbed2NestedStruct1()};
	FCriticalSection Prop2Mutex;
	FTestbed2NestedStruct2 Prop2{FTestbed2NestedStruct2()};
	FCriticalSection Prop3Mutex;
	FTestbed2NestedStruct3 Prop3{FTestbed2NestedStruct3()};
};
DEFINE_LOG_CATEGORY(LogTestbed2NestedStruct3InterfaceMsgBusClient);

UTestbed2NestedStruct3InterfaceMsgBusClient::UTestbed2NestedStruct3InterfaceMsgBusClient()
	: UAbstractTestbed2NestedStruct3Interface()
	, _SentData(MakePimpl<Testbed2NestedStruct3InterfacePropertiesMsgBusData>())
{
	/* m_sink = std::make_shared<FOLinkSink>("testbed2.NestedStruct3Interface"); */
}

UTestbed2NestedStruct3InterfaceMsgBusClient::~UTestbed2NestedStruct3InterfaceMsgBusClient() = default;

void UTestbed2NestedStruct3InterfaceMsgBusClient::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);

	Connect();
}

void UTestbed2NestedStruct3InterfaceMsgBusClient::Deinitialize()
{
	Disconnect();

	Super::Deinitialize();
}

void UTestbed2NestedStruct3InterfaceMsgBusClient::Connect()
{
	if (IsConnected())
	{
		return;
	}

	if (Testbed2NestedStruct3InterfaceMsgBusEndpoint.IsValid() && !ServiceAddress.IsValid())
	{
		DiscoverService();
		return;
	}

	// clang-format off
	Testbed2NestedStruct3InterfaceMsgBusEndpoint = FMessageEndpoint::Builder("ApiGear/Testbed2/NestedStruct3Interface/Client")
		.Handling<FTestbed2NestedStruct3InterfaceInitMessage>(this, &UTestbed2NestedStruct3InterfaceMsgBusClient::OnConnectionInit)
		.Handling<FTestbed2NestedStruct3InterfaceServiceDisconnectMessage>(this, &UTestbed2NestedStruct3InterfaceMsgBusClient::OnServiceClosedConnection)
		.Handling<FTestbed2NestedStruct3InterfaceSig1SignalMessage>(this, &UTestbed2NestedStruct3InterfaceMsgBusClient::OnSig1)

		.Handling<FTestbed2NestedStruct3InterfaceSig2SignalMessage>(this, &UTestbed2NestedStruct3InterfaceMsgBusClient::OnSig2)

		.Handling<FTestbed2NestedStruct3InterfaceSig3SignalMessage>(this, &UTestbed2NestedStruct3InterfaceMsgBusClient::OnSig3)
		.Handling<FTestbed2NestedStruct3InterfaceProp1ChangedMessage>(this, &UTestbed2NestedStruct3InterfaceMsgBusClient::OnProp1Changed)

		.Handling<FTestbed2NestedStruct3InterfaceProp2ChangedMessage>(this, &UTestbed2NestedStruct3InterfaceMsgBusClient::OnProp2Changed)

		.Handling<FTestbed2NestedStruct3InterfaceProp3ChangedMessage>(this, &UTestbed2NestedStruct3InterfaceMsgBusClient::OnProp3Changed)
		.Handling<FTestbed2NestedStruct3InterfaceFunc1ReplyMessage>(this, &UTestbed2NestedStruct3InterfaceMsgBusClient::OnFunc1Reply)
		.Handling<FTestbed2NestedStruct3InterfaceFunc2ReplyMessage>(this, &UTestbed2NestedStruct3InterfaceMsgBusClient::OnFunc2Reply)
		.Handling<FTestbed2NestedStruct3InterfaceFunc3ReplyMessage>(this, &UTestbed2NestedStruct3InterfaceMsgBusClient::OnFunc3Reply)
		.Build();
	// clang-format on

	DiscoverService();
}

void UTestbed2NestedStruct3InterfaceMsgBusClient::Disconnect()
{
	if (!IsConnected())
	{
		return;
	}

	auto msg = new FTestbed2NestedStruct3InterfaceClientDisconnectMessage();

	if (Testbed2NestedStruct3InterfaceMsgBusEndpoint.IsValid())
	{
		Testbed2NestedStruct3InterfaceMsgBusEndpoint->Send<FTestbed2NestedStruct3InterfaceClientDisconnectMessage>(msg, EMessageFlags::Reliable,
			nullptr,
			TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
			FTimespan::Zero(),
			FDateTime::MaxValue());
	}

	Testbed2NestedStruct3InterfaceMsgBusEndpoint.Reset();
	ServiceAddress.Invalidate();
	_ConnectionStatusChanged.Broadcast(false);
}

void UTestbed2NestedStruct3InterfaceMsgBusClient::DiscoverService()
{
	if (Testbed2NestedStruct3InterfaceMsgBusEndpoint.IsValid())
	{
		Testbed2NestedStruct3InterfaceMsgBusEndpoint->Publish<FTestbed2NestedStruct3InterfaceDiscoveryMessage>(new FTestbed2NestedStruct3InterfaceDiscoveryMessage());
	}
}

bool UTestbed2NestedStruct3InterfaceMsgBusClient::IsConnected() const
{
	return Testbed2NestedStruct3InterfaceMsgBusEndpoint.IsValid() && ServiceAddress.IsValid();
}

void UTestbed2NestedStruct3InterfaceMsgBusClient::OnConnectionInit(const FTestbed2NestedStruct3InterfaceInitMessage& InInitMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (!ServiceAddress.IsValid())
	{
		ServiceAddress = Context->GetSender();
		const bool bProp1Changed = InInitMessage.Prop1 != Prop1;
		if (bProp1Changed)
		{
			Prop1 = InInitMessage.Prop1;
			Execute__GetSignals(this)->OnProp1Changed.Broadcast(Prop1);
		}

		const bool bProp2Changed = InInitMessage.Prop2 != Prop2;
		if (bProp2Changed)
		{
			Prop2 = InInitMessage.Prop2;
			Execute__GetSignals(this)->OnProp2Changed.Broadcast(Prop2);
		}

		const bool bProp3Changed = InInitMessage.Prop3 != Prop3;
		if (bProp3Changed)
		{
			Prop3 = InInitMessage.Prop3;
			Execute__GetSignals(this)->OnProp3Changed.Broadcast(Prop3);
		}

		_ConnectionStatusChanged.Broadcast(true);
	}
	else
	{
		UE_LOG(LogTestbed2NestedStruct3InterfaceMsgBusClient, Error, TEXT("Got a second init message - should not happen"));
	}
}

void UTestbed2NestedStruct3InterfaceMsgBusClient::OnServiceClosedConnection(const FTestbed2NestedStruct3InterfaceServiceDisconnectMessage& /*InMessage*/, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		return;
	}

	ServiceAddress.Invalidate();
	_ConnectionStatusChanged.Broadcast(false);
}

FTestbed2NestedStruct1 UTestbed2NestedStruct3InterfaceMsgBusClient::GetProp1_Implementation() const
{
	return Prop1;
}

void UTestbed2NestedStruct3InterfaceMsgBusClient::SetProp1_Implementation(const FTestbed2NestedStruct1& InProp1)
{
	if (!IsConnected())
	{
		UE_LOG(LogTestbed2NestedStruct3InterfaceMsgBusClient, Error, TEXT("Client has no connection to service."));
		return;
	}

	// only send change requests if the value changed -> reduce network load
	if (GetProp1_Implementation() == InProp1)
	{
		return;
	}

	// only send change requests if the value wasn't already sent -> reduce network load
	{
		FScopeLock Lock(&(_SentData->Prop1Mutex));
		if (_SentData->Prop1 == InProp1)
		{
			return;
		}
	}

	auto msg = new FTestbed2NestedStruct3InterfaceSetProp1RequestMessage();
	msg->Prop1 = InProp1;

	if (Testbed2NestedStruct3InterfaceMsgBusEndpoint.IsValid())
	{
		Testbed2NestedStruct3InterfaceMsgBusEndpoint->Send<FTestbed2NestedStruct3InterfaceSetProp1RequestMessage>(msg, EMessageFlags::Reliable,
			nullptr,
			TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
			FTimespan::Zero(),
			FDateTime::MaxValue());
		FScopeLock Lock(&(_SentData->Prop1Mutex));
		_SentData->Prop1 = InProp1;
	}
}

FTestbed2NestedStruct2 UTestbed2NestedStruct3InterfaceMsgBusClient::GetProp2_Implementation() const
{
	return Prop2;
}

void UTestbed2NestedStruct3InterfaceMsgBusClient::SetProp2_Implementation(const FTestbed2NestedStruct2& InProp2)
{
	if (!IsConnected())
	{
		UE_LOG(LogTestbed2NestedStruct3InterfaceMsgBusClient, Error, TEXT("Client has no connection to service."));
		return;
	}

	// only send change requests if the value changed -> reduce network load
	if (GetProp2_Implementation() == InProp2)
	{
		return;
	}

	// only send change requests if the value wasn't already sent -> reduce network load
	{
		FScopeLock Lock(&(_SentData->Prop2Mutex));
		if (_SentData->Prop2 == InProp2)
		{
			return;
		}
	}

	auto msg = new FTestbed2NestedStruct3InterfaceSetProp2RequestMessage();
	msg->Prop2 = InProp2;

	if (Testbed2NestedStruct3InterfaceMsgBusEndpoint.IsValid())
	{
		Testbed2NestedStruct3InterfaceMsgBusEndpoint->Send<FTestbed2NestedStruct3InterfaceSetProp2RequestMessage>(msg, EMessageFlags::Reliable,
			nullptr,
			TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
			FTimespan::Zero(),
			FDateTime::MaxValue());
		FScopeLock Lock(&(_SentData->Prop2Mutex));
		_SentData->Prop2 = InProp2;
	}
}

FTestbed2NestedStruct3 UTestbed2NestedStruct3InterfaceMsgBusClient::GetProp3_Implementation() const
{
	return Prop3;
}

void UTestbed2NestedStruct3InterfaceMsgBusClient::SetProp3_Implementation(const FTestbed2NestedStruct3& InProp3)
{
	if (!IsConnected())
	{
		UE_LOG(LogTestbed2NestedStruct3InterfaceMsgBusClient, Error, TEXT("Client has no connection to service."));
		return;
	}

	// only send change requests if the value changed -> reduce network load
	if (GetProp3_Implementation() == InProp3)
	{
		return;
	}

	// only send change requests if the value wasn't already sent -> reduce network load
	{
		FScopeLock Lock(&(_SentData->Prop3Mutex));
		if (_SentData->Prop3 == InProp3)
		{
			return;
		}
	}

	auto msg = new FTestbed2NestedStruct3InterfaceSetProp3RequestMessage();
	msg->Prop3 = InProp3;

	if (Testbed2NestedStruct3InterfaceMsgBusEndpoint.IsValid())
	{
		Testbed2NestedStruct3InterfaceMsgBusEndpoint->Send<FTestbed2NestedStruct3InterfaceSetProp3RequestMessage>(msg, EMessageFlags::Reliable,
			nullptr,
			TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
			FTimespan::Zero(),
			FDateTime::MaxValue());
		FScopeLock Lock(&(_SentData->Prop3Mutex));
		_SentData->Prop3 = InProp3;
	}
}

FTestbed2NestedStruct1 UTestbed2NestedStruct3InterfaceMsgBusClient::Func1_Implementation(const FTestbed2NestedStruct1& InParam1)
{
	if (!IsConnected())
	{
		UE_LOG(LogTestbed2NestedStruct3InterfaceMsgBusClient, Error, TEXT("Client has no connection to service."));

		return FTestbed2NestedStruct1();
	}

	auto msg = new FTestbed2NestedStruct3InterfaceFunc1RequestMessage();
	msg->RepsonseId = FGuid::NewGuid();
	msg->Param1 = InParam1;

	if (Testbed2NestedStruct3InterfaceMsgBusEndpoint.IsValid())
	{
		TPromise<FTestbed2NestedStruct1> Promise;
		StorePromise(msg->RepsonseId, Promise);

		Testbed2NestedStruct3InterfaceMsgBusEndpoint->Send<FTestbed2NestedStruct3InterfaceFunc1RequestMessage>(msg, EMessageFlags::Reliable,
			nullptr,
			TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
			FTimespan::Zero(),
			FDateTime::MaxValue());

		return Promise.GetFuture().Get();
	}

	return FTestbed2NestedStruct1();
}

void UTestbed2NestedStruct3InterfaceMsgBusClient::OnFunc1Reply(const FTestbed2NestedStruct3InterfaceFunc1ReplyMessage& InFunc1ReplyMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	FulfillPromise(InFunc1ReplyMessage.RepsonseId, InFunc1ReplyMessage.Result);
}

FTestbed2NestedStruct1 UTestbed2NestedStruct3InterfaceMsgBusClient::Func2_Implementation(const FTestbed2NestedStruct1& InParam1, const FTestbed2NestedStruct2& InParam2)
{
	if (!IsConnected())
	{
		UE_LOG(LogTestbed2NestedStruct3InterfaceMsgBusClient, Error, TEXT("Client has no connection to service."));

		return FTestbed2NestedStruct1();
	}

	auto msg = new FTestbed2NestedStruct3InterfaceFunc2RequestMessage();
	msg->RepsonseId = FGuid::NewGuid();
	msg->Param1 = InParam1;
	msg->Param2 = InParam2;

	if (Testbed2NestedStruct3InterfaceMsgBusEndpoint.IsValid())
	{
		TPromise<FTestbed2NestedStruct1> Promise;
		StorePromise(msg->RepsonseId, Promise);

		Testbed2NestedStruct3InterfaceMsgBusEndpoint->Send<FTestbed2NestedStruct3InterfaceFunc2RequestMessage>(msg, EMessageFlags::Reliable,
			nullptr,
			TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
			FTimespan::Zero(),
			FDateTime::MaxValue());

		return Promise.GetFuture().Get();
	}

	return FTestbed2NestedStruct1();
}

void UTestbed2NestedStruct3InterfaceMsgBusClient::OnFunc2Reply(const FTestbed2NestedStruct3InterfaceFunc2ReplyMessage& InFunc2ReplyMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	FulfillPromise(InFunc2ReplyMessage.RepsonseId, InFunc2ReplyMessage.Result);
}

FTestbed2NestedStruct1 UTestbed2NestedStruct3InterfaceMsgBusClient::Func3_Implementation(const FTestbed2NestedStruct1& InParam1, const FTestbed2NestedStruct2& InParam2, const FTestbed2NestedStruct3& InParam3)
{
	if (!IsConnected())
	{
		UE_LOG(LogTestbed2NestedStruct3InterfaceMsgBusClient, Error, TEXT("Client has no connection to service."));

		return FTestbed2NestedStruct1();
	}

	auto msg = new FTestbed2NestedStruct3InterfaceFunc3RequestMessage();
	msg->RepsonseId = FGuid::NewGuid();
	msg->Param1 = InParam1;
	msg->Param2 = InParam2;
	msg->Param3 = InParam3;

	if (Testbed2NestedStruct3InterfaceMsgBusEndpoint.IsValid())
	{
		TPromise<FTestbed2NestedStruct1> Promise;
		StorePromise(msg->RepsonseId, Promise);

		Testbed2NestedStruct3InterfaceMsgBusEndpoint->Send<FTestbed2NestedStruct3InterfaceFunc3RequestMessage>(msg, EMessageFlags::Reliable,
			nullptr,
			TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
			FTimespan::Zero(),
			FDateTime::MaxValue());

		return Promise.GetFuture().Get();
	}

	return FTestbed2NestedStruct1();
}

void UTestbed2NestedStruct3InterfaceMsgBusClient::OnFunc3Reply(const FTestbed2NestedStruct3InterfaceFunc3ReplyMessage& InFunc3ReplyMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	FulfillPromise(InFunc3ReplyMessage.RepsonseId, InFunc3ReplyMessage.Result);
}

void UTestbed2NestedStruct3InterfaceMsgBusClient::OnSig1(const FTestbed2NestedStruct3InterfaceSig1SignalMessage& InSig1Message, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogTestbed2NestedStruct3InterfaceMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	Execute__GetSignals(this)->OnSig1Signal.Broadcast(InSig1Message.Param1);
	return;
}

void UTestbed2NestedStruct3InterfaceMsgBusClient::OnSig2(const FTestbed2NestedStruct3InterfaceSig2SignalMessage& InSig2Message, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogTestbed2NestedStruct3InterfaceMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	Execute__GetSignals(this)->OnSig2Signal.Broadcast(InSig2Message.Param1, InSig2Message.Param2);
	return;
}

void UTestbed2NestedStruct3InterfaceMsgBusClient::OnSig3(const FTestbed2NestedStruct3InterfaceSig3SignalMessage& InSig3Message, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogTestbed2NestedStruct3InterfaceMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	Execute__GetSignals(this)->OnSig3Signal.Broadcast(InSig3Message.Param1, InSig3Message.Param2, InSig3Message.Param3);
	return;
}

void UTestbed2NestedStruct3InterfaceMsgBusClient::OnProp1Changed(const FTestbed2NestedStruct3InterfaceProp1ChangedMessage& InProp1Message, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogTestbed2NestedStruct3InterfaceMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	const bool bProp1Changed = InProp1Message.Prop1 != Prop1;
	if (bProp1Changed)
	{
		Prop1 = InProp1Message.Prop1;
		Execute__GetSignals(this)->OnProp1Changed.Broadcast(Prop1);
	}
}

void UTestbed2NestedStruct3InterfaceMsgBusClient::OnProp2Changed(const FTestbed2NestedStruct3InterfaceProp2ChangedMessage& InProp2Message, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogTestbed2NestedStruct3InterfaceMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	const bool bProp2Changed = InProp2Message.Prop2 != Prop2;
	if (bProp2Changed)
	{
		Prop2 = InProp2Message.Prop2;
		Execute__GetSignals(this)->OnProp2Changed.Broadcast(Prop2);
	}
}

void UTestbed2NestedStruct3InterfaceMsgBusClient::OnProp3Changed(const FTestbed2NestedStruct3InterfaceProp3ChangedMessage& InProp3Message, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogTestbed2NestedStruct3InterfaceMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	const bool bProp3Changed = InProp3Message.Prop3 != Prop3;
	if (bProp3Changed)
	{
		Prop3 = InProp3Message.Prop3;
		Execute__GetSignals(this)->OnProp3Changed.Broadcast(Prop3);
	}
}

template <typename ResultType>
bool UTestbed2NestedStruct3InterfaceMsgBusClient::StorePromise(const FGuid& Id, TPromise<ResultType>& Promise)
{
	FScopeLock Lock(&ReplyPromisesMapCS);
	return ReplyPromisesMap.Add(Id, &Promise) != nullptr;
}

template <typename ResultType>
bool UTestbed2NestedStruct3InterfaceMsgBusClient::FulfillPromise(const FGuid& Id, const ResultType& Value)
{
	TPromise<ResultType>* PromisePtr = nullptr;

	{
		FScopeLock Lock(&ReplyPromisesMapCS);
		if (auto** Found = ReplyPromisesMap.Find(Id))
		{
			PromisePtr = static_cast<TPromise<ResultType>*>(*Found);
			ReplyPromisesMap.Remove(Id);
		}
	}

	if (PromisePtr)
	{
		PromisePtr->SetValue(Value);
		return true;
	}
	return false;
}

template bool UTestbed2NestedStruct3InterfaceMsgBusClient::StorePromise<FTestbed2NestedStruct1>(const FGuid& Id, TPromise<FTestbed2NestedStruct1>& Promise);
template bool UTestbed2NestedStruct3InterfaceMsgBusClient::FulfillPromise<FTestbed2NestedStruct1>(const FGuid& Id, const FTestbed2NestedStruct1& Value);
