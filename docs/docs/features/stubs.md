---
sidebar_position: 2
sidebar_label: "Stubs"
title: "Stubs Feature: GameInstance Subsystem Implementation for Unreal Engine"
description: "Generate ready-to-use stub implementations as Unreal Engine GameInstance Subsystems. Includes test fixtures and property change notifications."
keywords: [gameinstance subsystem, stub implementation, unreal engine, test fixtures, apigear]
---

import CodeBlock from '@theme/CodeBlock';
import helloWorldModuleComponent from '!!raw-loader!./data/helloworld.module.yaml';

# Stubs

The `stubs` feature generates:

- Fully instantiable implementation classes as GameInstance Subsystems
- A starting point for your business logic
- Test fixtures for unit testing your implementations

The stub implementations inherit from the abstract base classes generated by the [api](api.md) feature and provide complete, working implementations that you can customize.

:::tip
Stub files are marked with `preserve: true` in the template rules. This means they won't be overwritten when you regenerate code, so your custom logic is safe.
:::

:::note
For network connectivity, you can use [OLink](olink.md) clients instead of stubs. Both implement the same interface, so you can swap implementations without changing your application code.
:::

## File overview for module

With our example API definition:

<details>
  <summary>Hello World API (click to expand)</summary>
  <CodeBlock language="yaml" showLineNumbers>{helloWorldModuleComponent}</CodeBlock>
</details>

The following file structure is generated in the `IoWorldImplementation` module:

```bash
ðŸ“‚IoWorld/Source/IoWorldImplementation
 â”£ ðŸ“‚Private
 â”ƒ â”£ ðŸ“‚Implementation
 â”ƒ â”ƒ â”— ðŸ“œIoWorldHello.cpp
 â”ƒ â”£ ðŸ“‚Tests
 â”ƒ â”ƒ â”£ ðŸ“œIoWorldHelloImpl.spec.cpp
 â”ƒ â”ƒ â”£ ðŸ“œIoWorldHelloImplFixture.h
 â”ƒ â”ƒ â”— ðŸ“œIoWorldHelloImplFixture.cpp
 â”ƒ â”— ðŸ“‚Generated
 â”ƒ   â”— ðŸ“œIoWorldImplementation.cpp
 â”£ ðŸ“‚Public
 â”ƒ â”— ðŸ“‚IoWorld
 â”ƒ   â”£ ðŸ“‚Implementation
 â”ƒ   â”ƒ â”— ðŸ“œIoWorldHello.h
 â”ƒ   â”— ðŸ“œIoWorldImplementation.h
 â”— ðŸ“œIoWorldImplementation.Build.cs
```

## Implementation

Files `IoWorldHello.h` and `IoWorldHello.cpp` contain your implementation of the `IIoWorldHelloInterface`. The implementation class inherits from `UAbstractIoWorldHello` (see [api](api.md)) which provides property storage, Publisher for notifications, and subsystem lifecycle.

### GameInstance Subsystem

The implementation is a `UGameInstanceSubsystem`, which means:

- **Automatic lifecycle**: Created when the GameInstance initializes, destroyed when it shuts down
- **Singleton access**: Only one instance exists per GameInstance
- **Easy access**: Available from any Actor, Component, or other object via `GetGameInstance()->GetSubsystem<UIoWorldHelloImplementation>()`
- **Blueprint-friendly**: Accessible through "Get Game Instance Subsystem" node

### Properties

Property getters and setters are pre-implemented. The setter automatically:
1. Checks if the value actually changed (avoiding unnecessary notifications)
2. Updates the stored value (inherited from abstract class)
3. Broadcasts the change via the Publisher to all subscribers

You typically don't need to modify the property accessors unless you need custom validation or side effects.

Use `_ResetProperties()` to restore all properties to their default values (with change broadcasts).

### Operations

Operations are generated with empty implementations for you to fill in:

```cpp
int32 UIoWorldHelloImplementation::Say(const FIoWorldMessage& Msg, EIoWorldWhen When)
{
    // Add your business logic here
    return ProcessMessage(Msg, When);
}
```

The generated code includes CPU profiler instrumentation (`TRACE_CPUPROFILER_EVENT_SCOPE_STR`) for performance tracing in Unreal Insights.

#### Async Operations

The abstract base class provides async wrappers that automatically call your synchronous implementation on a thread pool. You don't need to implement async versions yourself:

```cpp
// Your implementation only needs the synchronous method
int32 UIoWorldHelloImplementation::Say(const FIoWorldMessage& Msg, EIoWorldWhen When)
{
    // Your business logic here
    return ProcessMessage(Msg);
}

// Callers can use async variants - they automatically call Say() on a thread pool
TFuture<int32> Future = Hello->SayAsync(Msg, EIoWorldWhen::IWW_Now);
```

If you need custom async behavior (e.g., for operations that are naturally asynchronous), you can override the async methods:

```cpp
// Override for custom async behavior
TFuture<int32> UIoWorldHelloImplementation::SayAsync(const FIoWorldMessage& Msg, EIoWorldWhen When)
{
    // Custom async implementation
    TPromise<int32> Promise;
    TFuture<int32> Future = Promise.GetFuture();

    // Start async work
    AsyncTask(ENamedThreads::AnyBackgroundThreadNormalTask, [this, Msg, When, Promise = MoveTemp(Promise)]() mutable
    {
        int32 Result = DoAsyncWork(Msg, When);
        Promise.SetValue(Result);
    });

    return Future;
}
```

:::tip
When implementing operations, remember to:
- Emit signals when appropriate using the Publisher's broadcast methods
- Handle errors gracefully
- The default async implementation runs on a thread pool - ensure thread safety if needed
:::

### Signals

To emit a signal from your implementation, use the Publisher:

```cpp
void UIoWorldHelloImplementation::SomeInternalMethod()
{
    FIoWorldMessage Msg;
    Msg.content = TEXT("Something happened");

    // Emit the signal via Publisher
    _GetPublisher()->BroadcastJustSaidSignal(Msg);
}
```

## Accessing the Implementation

### Module Dependency

Add the Implementation module to your `.Build.cs`:

```cs
PublicDependencyModuleNames.AddRange(new string[] { "IoWorldImplementation" });
```

### From Blueprints

1. Use the "Get Game Instance Subsystem" node
2. Select `UIoWorldHelloImplementation` as the class
3. Use the returned reference to call operations or bind to events

### From C++

```cpp
#include "IoWorld/Implementation/IoWorldHello.h"

// From any UObject with access to the world
UIoWorldHelloImplementation* Hello = GetGameInstance()->GetSubsystem<UIoWorldHelloImplementation>();
if (Hello)
{
    FIoWorldMessage Msg;
    Msg.content = TEXT("Hello");
    Hello->Say(Msg, EIoWorldWhen::IWW_Now);
}
```

Using `TScriptInterface` for interface-based access:

```cpp
#include "IoWorld/Generated/api/IoWorldHelloInterface.h"
#include "IoWorld/Implementation/IoWorldHello.h"

TScriptInterface<IIoWorldHelloInterface> Hello =
    GetGameInstance()->GetSubsystem<UIoWorldHelloImplementation>();

// Now use through the interface
Hello->SetLast(Msg);
```

## Tests

The stubs feature generates test fixtures for each interface.

### Test Files

- `IoWorldHelloImpl.spec.cpp` - Test specifications using Unreal's automation testing framework
- `IoWorldHelloImplFixture.h/cpp` - Test fixture with setup and helper methods

The generated tests cover:
- Property default values
- Property change notifications (both C++ and Blueprint delegates)
- Operations (sync and async)
- Signals (both C++ and Blueprint delegates)

### Running Tests

Run the generated tests using Unreal's test framework:

1. **From Editor**: Window > Developer Tools > Session Frontend > Automation
2. **From Command Line**:
   ```bash
   UnrealEditor-Cmd.exe YourProject.uproject -ExecCmds="Automation RunTests IoWorld"
   ```

### Adding Your Own Tests

The fixture provides access to the implementation through `GetImplementation()`. Add tests to the spec file:

```cpp
It("MyCustomTest", [this]()
{
    FIoWorldMessage Msg;
    Msg.content = TEXT("Test");
    int32 Result = ImplFixture->GetImplementation()->Say(Msg, EIoWorldWhen::IWW_Now);
    TestEqual(TEXT("Expected result"), Result, ExpectedValue);
});
```

## Best Practices

### Thread Safety

The generated stubs are not thread-safe by default. If you need thread-safe access, use Unreal's `FCriticalSection` for property access and ensure Publisher broadcasts happen on the game thread via `AsyncTask(ENamedThreads::GameThread, ...)`.

### Initialization

Override the `Initialize` method from the abstract base class for setup:

```cpp
void UIoWorldHelloImplementation::Initialize(FSubsystemCollectionBase& Collection)
{
    Super::Initialize(Collection);

    // Initialize default values
    Last.content = TEXT("Default");

    // Set up any required connections or resources
}
```

### Cleanup

Override `Deinitialize` to clean up resources:

```cpp
void UIoWorldHelloImplementation::Deinitialize()
{
    // Clean up connections, timers, etc.

    Super::Deinitialize();
}
```
