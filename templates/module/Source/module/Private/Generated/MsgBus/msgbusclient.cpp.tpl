{{- /* Copyright Epic Games, Inc. All Rights Reserved */ -}}
/**{{ template "copyright" }}*/
{{- $ModuleName := Camel .Module.Name}}
{{- $IfaceName := Camel .Interface.Name }}
{{- $Category := printf "ApiGear|%s|%s" $ModuleName $IfaceName }}
{{- $DisplayName := printf "%s%s" $ModuleName $IfaceName }}
{{- $Class := printf "U%sMsgBusClient" $DisplayName}}
{{- $abstractclass := printf "UAbstract%s%s" (Camel .Module.Name) (Camel .Interface.Name) }}
{{- $Iface := printf "%s%s" $ModuleName $IfaceName }}
{{- $ifaceId := printf "%s.%s" .Module.Name .Interface.Name}}

////////////////////////////////
// WARNING AUTOGENERATED
// DO NOT MODIFY
///////////////////////////////

#include "Generated/MsgBus/{{$Iface}}MsgBusClient.h"
#include "Generated/MsgBus/{{$Iface}}MsgBusMessages.h"
#include "Async/Async.h"
#include "Engine/Engine.h"
#include "TimerManager.h"
#include "Misc/DateTime.h"
#include "GenericPlatform/GenericPlatformMath.h"
#include "GenericPlatform/GenericPlatformTime.h"
#include "MessageEndpointBuilder.h"
#include "MessageEndpoint.h"

{{- if len .Interface.Properties }}
    {{- $shouldIncludeAtomic := 0 -}}
    {{- $shouldIncludeMutex := 0 -}}
{{- range $i, $e := .Interface.Properties }}
	{{- if ( ueIsStdSimpleType . ) }}
	{{- $shouldIncludeAtomic = 1}}
	{{- else}}
	{{- $shouldIncludeMutex = 1}}
	{{- end}}
{{- end}}
{{- if (eq $shouldIncludeAtomic  1) }}
#include <atomic>
{{- end}}
{{- if (eq $shouldIncludeMutex 1) }}
#include "HAL/CriticalSection.h"
{{- end}}

/**
   \brief data structure to hold the last sent property values
*/
struct {{$Iface}}PropertiesMsgBusData
{
{{- range $i, $e := .Interface.Properties }}
	{{- if ( ueIsStdSimpleType . ) }}
	std::atomic<{{ueReturn "" .}}> {{ueVar "" .}}{ {{- ueDefault "" . -}} };
	{{- else }}
	FCriticalSection {{ueVar "" .}}Mutex;
	{{ueReturn "" .}} {{ueVar "" .}}{ {{- ueDefault "" . -}} };
	{{- end }}
{{- end }}
};
{{- end }}
DEFINE_LOG_CATEGORY(Log{{$Iface}}MsgBusClient);
{{ if .Interface.Description }}
/**
   \brief {{.Interface.Description}}
*/
{{- end }}
{{$Class}}::{{$Class}}()
	: {{$abstractclass}}()
{{- if len .Interface.Properties }}
	, _SentData(MakePimpl<{{$Iface}}PropertiesMsgBusData>())
{{- end }}
{
	PingRTTBuffer.SetNumZeroed(PING_RTT_BUFFER_SIZE);
}

{{$Class}}::~{{$Class}}() = default;

void {{$Class}}::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);
}

void {{$Class}}::Deinitialize()
{
	_Disconnect();

	Super::Deinitialize();
}

void {{$Class}}::_Connect()
{
	if (!_HeartbeatTimerHandle.IsValid() && GetWorld())
	{
		GetWorld()->GetTimerManager().SetTimer(_HeartbeatTimerHandle, this, &{{$Class}}::_OnHeartbeat, _HeartbeatIntervalMS / 1000.0f, true);
	}

	if (_IsConnected())
	{
		UE_LOG(Log{{$Iface}}MsgBusClient, Log, TEXT("Already connected, cannot connect again."));
		return;
	}

	if ({{$Iface}}MsgBusEndpoint.IsValid() && !ServiceAddress.IsValid())
	{
		_DiscoverService();
		return;
	}

	// clang-format off
	{{$Iface}}MsgBusEndpoint = FMessageEndpoint::Builder("ApiGear/{{$ModuleName}}/{{$IfaceName}}/Client")
		.Handling<F{{$Iface}}InitMessage>(this, &{{$Class}}::OnConnectionInit)
		.Handling<F{{$Iface}}PongMessage>(this, &{{$Class}}::OnPong)
		.Handling<F{{$Iface}}ServiceDisconnectMessage>(this, &{{$Class}}::OnServiceClosedConnection)
{{- range $i, $e := .Interface.Signals }}
		.Handling<F{{$Iface}}{{Camel .Name}}SignalMessage>(this, &{{$Class}}::On{{Camel .Name}})
{{- end }}
{{- range $i, $e := .Interface.Properties }}
		.Handling<F{{$Iface}}{{Camel .Name}}ChangedMessage>(this, &{{$Class}}::On{{Camel .Name}}Changed)
{{- end }}
{{- range $i, $e := .Interface.Operations }}
{{- if not .Return.IsVoid }}
		.Handling<F{{$Iface}}{{Camel .Name}}ReplyMessage>(this, &{{$Class}}::On{{Camel .Name}}Reply)
{{- end }}
{{- end }}
		.Build();
	// clang-format on

	_DiscoverService();
}

void {{$Class}}::_Disconnect()
{
	_LastHbTimestamp = 0.0f;
	if (_HeartbeatTimerHandle.IsValid() && GetWorld())
	{
		GetWorld()->GetTimerManager().ClearTimer(_HeartbeatTimerHandle);
	}

	if (!_IsConnected())
	{
		return;
	}

	auto msg = new F{{$Iface}}ClientDisconnectMessage();

	{{$Iface}}MsgBusEndpoint->Send<F{{$Iface}}ClientDisconnectMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());

	{{$Iface}}MsgBusEndpoint.Reset();
	ServiceAddress.Invalidate();
	_ConnectionStatusChanged.Broadcast(false);
}

void {{$Class}}::_DiscoverService()
{
	if (!{{$Iface}}MsgBusEndpoint.IsValid())
	{
		return;
	}

	auto msg = new F{{$Iface}}DiscoveryMessage();
	{{$Iface}}MsgBusEndpoint->Publish<F{{$Iface}}DiscoveryMessage>(msg);
}

bool {{$Class}}::_IsConnected() const
{
	return {{$Iface}}MsgBusEndpoint.IsValid() && ServiceAddress.IsValid();
}

void {{$Class}}::OnConnectionInit(const F{{$Iface}}InitMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress.IsValid())
	{
		UE_LOG(Log{{$Iface}}MsgBusClient, Warning, TEXT("Got a second init message - should not happen"));
		return;
	}

	ServiceAddress = Context->GetSender();
	// reset ping stats for a new connection
	PingRTTBuffer.Empty();
	PingRTTBuffer.SetNumZeroed(PING_RTT_BUFFER_SIZE);
	CurrentPingCounter = 0;
	Stats.CurrentRTT_MS = 0.0f;
	Stats.AverageRTT_MS = 0.0f;
	Stats.MaxRTT_MS = 0.0f;
	Stats.MinRTT_MS = 10000.0f;

	const bool b_ClientPingIntervalMSChanged = InMessage._ClientPingIntervalMS != _HeartbeatIntervalMS;
	if (b_ClientPingIntervalMSChanged)
	{
		_HeartbeatIntervalMS = InMessage._ClientPingIntervalMS;

		if (_HeartbeatTimerHandle.IsValid() && GetWorld())
		{
			GetWorld()->GetTimerManager().ClearTimer(_HeartbeatTimerHandle);
		}

		if (!_HeartbeatTimerHandle.IsValid() && GetWorld())
		{
			GetWorld()->GetTimerManager().SetTimer(_HeartbeatTimerHandle, this, &{{$Class}}::_OnHeartbeat, _HeartbeatIntervalMS / 1000.0f, true);
		}
	}

{{- range $i, $e := .Interface.Properties }}
{{- if $i }}{{nl}}{{ end }}
	const bool b{{ueVar "" .}}Changed = InMessage.{{ueVar "" .}} != {{ueVar "" .}};
	if (b{{ueVar "" .}}Changed)
	{
		{{ueVar "" .}} = InMessage.{{ueVar "" .}};
		Execute__GetSignals(this)->On{{ Camel .Name }}Changed.Broadcast({{ueVar "" .}});
	}
{{- end }}

	_ConnectionStatusChanged.Broadcast(true);
}

void {{$Class}}::_OnHeartbeat()
{
	if (_LastHbTimestamp > 0.1)
	{
		const double DeltaMS = (FPlatformTime::Seconds() - _LastHbTimestamp) * 1000.0;

		if (DeltaMS > 2 * _HeartbeatIntervalMS)
		{
			// service seems to be dead or not responding - reset connection
			ServiceAddress.Invalidate();
			_LastHbTimestamp = 0.0;
			_ConnectionStatusChanged.Broadcast(false);
		}
	}

	if (!_IsConnected())
	{
		// only log warning message once a second
		if (FPlatformTime::Seconds() - _LastConnectionWarningTimestamp > 1.0)
		{
			UE_LOG(Log{{$Iface}}MsgBusClient, Warning, TEXT("Heartbeat failed. Client has no connection to service. Reconnecting ..."));
			_LastConnectionWarningTimestamp = FPlatformTime::Seconds();
		}

		_Connect();
		return;
	}

	auto msg = new F{{$DisplayName}}PingMessage();
	msg->Timestamp = FPlatformTime::Seconds();

	{{$Iface}}MsgBusEndpoint->Send<F{{$DisplayName}}PingMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());
}

float {{$Class}}::_CalculateAverageRTT() const
{
	if (CurrentPingCounter == 0)
	{
		return 0.0f;
	}

	float TotalRTT = 0.0f;

	for (const float& RTT : PingRTTBuffer)
	{
		TotalRTT += RTT;
	}

	return CurrentPingCounter > 0 ? TotalRTT / CurrentPingCounter : 0.0f;
}

void {{$Class}}::OnPong(const F{{$Iface}}PongMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	_LastHbTimestamp = InMessage.Timestamp;

	const double Current = FPlatformTime::Seconds();
	const double DeltaMS = (Current - InMessage.Timestamp) * 1000.0f;

	Stats.CurrentRTT_MS = DeltaMS;
	if (CurrentPingCounter < PING_RTT_BUFFER_SIZE)
	{
		CurrentPingCounter++;
	}
	PingRTTBuffer.RemoveAt(0);
	PingRTTBuffer.Add(Stats.CurrentRTT_MS);
	Stats.AverageRTT_MS = _CalculateAverageRTT();
	Stats.MaxRTT_MS = FGenericPlatformMath::Max(Stats.MaxRTT_MS, Stats.CurrentRTT_MS);
	Stats.MinRTT_MS = FGenericPlatformMath::Min(Stats.MinRTT_MS, Stats.CurrentRTT_MS);

	_StatsUpdated.Broadcast(Stats);
}

const F{{$DisplayName}}Stats& {{$Class}}::_GetStats() const
{
	return Stats;
}

void {{$Class}}::OnServiceClosedConnection(const F{{$Iface}}ServiceDisconnectMessage& /*InMessage*/, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		return;
	}

	_LastHbTimestamp = 0.0;
	ServiceAddress.Invalidate();
	_ConnectionStatusChanged.Broadcast(false);
}

{{- if len .Interface.Properties }}{{ nl }}{{ end }}
{{- range $i, $e := .Interface.Properties }}
{{- if $i }}{{nl}}{{ end }}
{{ueReturn "" .}} {{$Class}}::Get{{Camel .Name}}_Implementation() const
{
	return {{ueVar "" .}};
}

{{- if not .IsReadOnly }}{{nl}}
void {{$Class}}::Set{{Camel .Name}}_Implementation({{ueParam "In" .}})
{
	if (!_IsConnected())
	{
		UE_LOG(Log{{$Iface}}MsgBusClient, Error, TEXT("Client has no connection to service."));
		return;
	}

	// only send change requests if the value changed -> reduce network load
	if (Get{{Camel .Name}}_Implementation() == {{ueVar "In" .}})
	{
		return;
	}

	// only send change requests if the value wasn't already sent -> reduce network load
{{- if not ( ueIsStdSimpleType . )}}
	{
		FScopeLock Lock(&(_SentData->{{ueVar "" .}}Mutex));
		if (_SentData->{{ueVar "" .}} == {{ueVar "In" .}})
		{
			return;
		}
	}
{{- else}}
	if (_SentData->{{ueVar "" .}} == {{ueVar "In" .}})
	{
		return;
	}
{{- end }}

	auto msg = new F{{$Iface}}Set{{Camel .Name}}RequestMessage();
	msg->{{ueVar "" .}} = {{ueVar "In" .}};

	{{$Iface}}MsgBusEndpoint->Send<F{{$Iface}}Set{{Camel .Name}}RequestMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());
{{- if not ( ueIsStdSimpleType . ) }}
	FScopeLock Lock(&(_SentData->{{ueVar "" .}}Mutex));
{{- end }}
	_SentData->{{ueVar "" .}} = {{ueVar "In" .}};
}
{{- end }}
{{- end }}

{{- if len .Interface.Operations }}{{ nl }}{{ end }}
{{- range $i, $e := .Interface.Operations }}
{{- if $i }}{{nl}}{{ end }}
{{- if .Description }}
/**
   \brief {{.Description}}
*/
{{- end }}
{{- $returnVal := (ueReturn "" .Return)}}
{{$returnVal}} {{$Class}}::{{Camel .Name}}_Implementation({{ueParams "In" .Params}})
{
	if (!_IsConnected())
	{
		UE_LOG(Log{{$Iface}}MsgBusClient, Error, TEXT("Client has no connection to service."));
	{{- if .Return.IsVoid }}

		return;
	{{- else }}

		return {{ ueDefault "" .Return }};
	{{- end }}
	}

	auto msg = new F{{$Iface}}{{Camel .Name}}RequestMessage();
{{- if not .Return.IsVoid }}
	msg->ResponseId = FGuid::NewGuid();
{{- end }}
{{- range $i, $e := .Params }}
	msg->{{ueVar "" . }} = {{ueVar "In" . }};
{{- end }}

	{{- if not .Return.IsVoid }}
	TPromise<{{$returnVal}}> Promise;
	StorePromise(msg->ResponseId, Promise);
	{{- end }}

	{{$Iface}}MsgBusEndpoint->Send<F{{$Iface}}{{Camel .Name}}RequestMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());

{{- if .Return.IsVoid }}

	return;
{{- else }}

	return Promise.GetFuture().Get();
{{- end }}
}
{{- if not .Return.IsVoid }}

void {{$Class}}::On{{Camel .Name}}Reply(const F{{$Iface}}{{Camel .Name}}ReplyMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	FulfillPromise(InMessage.ResponseId, InMessage.Result);
}
{{- end }}
{{- end }}

{{- if len .Interface.Signals }}{{ nl }}{{ end }}
{{- range $i, $e := .Interface.Signals }}
{{- if $i }}{{nl}}{{ end }}
void {{$Class}}::On{{Camel .Name}}(const F{{$DisplayName}}{{Camel .Name}}SignalMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(Log{{$Iface}}MsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

{{- $sigName := Camel .Name}}

	Execute__GetSignals(this)->On{{Camel .Name}}Signal.Broadcast(
{{- range $i, $e := .Params -}}
	{{ if $i }}, {{end}}InMessage.{{ueVar "" .}}
{{- end -}}
	);
	return;
}
{{- end }}
{{- if len .Interface.Properties }}{{ nl }}{{ end }}
{{- range $i, $e := .Interface.Properties }}
{{- if $i }}{{nl}}{{ end }}
void {{$Class}}::On{{Camel .Name}}Changed(const F{{$DisplayName}}{{Camel .Name}}ChangedMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(Log{{$Iface}}MsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	const bool b{{ueVar "" .}}Changed = InMessage.{{ueVar "" .}} != {{ueVar "" .}};
	if (b{{ueVar "" .}}Changed)
	{
		{{ueVar "" .}} = InMessage.{{ueVar "" .}};
		Execute__GetSignals(this)->On{{Camel .Name}}Changed.Broadcast({{ueVar "" .}});
	}
}
{{- end }}

{{- if len .Interface.Operations }}

template <typename ResultType>
bool U{{$Iface}}MsgBusClient::StorePromise(const FGuid& Id, TPromise<ResultType>& Promise)
{
	FScopeLock Lock(&ReplyPromisesMapCS);
	return ReplyPromisesMap.Add(Id, &Promise) != nullptr;
}

template <typename ResultType>
bool U{{$Iface}}MsgBusClient::FulfillPromise(const FGuid& Id, const ResultType& Value)
{
	TPromise<ResultType>* PromisePtr = nullptr;

	{
		FScopeLock Lock(&ReplyPromisesMapCS);
		if (auto** Found = ReplyPromisesMap.Find(Id))
		{
			PromisePtr = static_cast<TPromise<ResultType>*>(*Found);
			ReplyPromisesMap.Remove(Id);
		}
	}

	if (PromisePtr)
	{
		PromisePtr->SetValue(Value);
		return true;
	}
	return false;
}
{{- $retTypes := getEmptyStringList}}
{{- range .Interface.Operations }}
{{- if not .Return.IsVoid }}
{{- $retType :=  ueReturn "" .Return }}
{{- $retTypes = (appendList $retTypes $retType) }}
{{- end }}
{{- end }}
{{- $retTypes = unique $retTypes }}
{{- if len $retTypes }}{{- nl }}{{- end }}
{{- range $retTypes }}
template bool U{{$Iface}}MsgBusClient::StorePromise<{{ .}}>(const FGuid& Id, TPromise<{{ .}}>& Promise);
template bool U{{$Iface}}MsgBusClient::FulfillPromise<{{ .}}>(const FGuid& Id, const {{ .}}& Value);
{{- end }}
{{- end }}
