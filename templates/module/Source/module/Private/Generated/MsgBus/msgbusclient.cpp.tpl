{{- /* Copyright Epic Games, Inc. All Rights Reserved */ -}}
/**{{ template "copyright" }}*/
{{- $ModuleName := Camel .Module.Name}}
{{- $IfaceName := Camel .Interface.Name }}
{{- $Category := printf "ApiGear|%s|%s" $ModuleName $IfaceName }}
{{- $DisplayName := printf "%s%s" $ModuleName $IfaceName }}
{{- $Class := printf "U%sMsgBusClient" $DisplayName}}
{{- $abstractclass := printf "UAbstract%s%s" (Camel .Module.Name) (Camel .Interface.Name) }}
{{- $Iface := printf "%s%s" $ModuleName $IfaceName }}
{{- $ifaceId := printf "%s.%s" .Module.Name .Interface.Name}}

////////////////////////////////
// WARNING AUTOGENERATED
// DO NOT MODIFY
///////////////////////////////

#include "Generated/MsgBus/{{$Iface}}MsgBusClient.h"
#include "Generated/MsgBus/{{$Iface}}MsgBusMessages.h"
#include "Async/Async.h"
#include "Engine/Engine.h"
#include "Misc/DateTime.h"
#include "MessageEndpointBuilder.h"
#include "MessageEndpoint.h"

{{- if len .Interface.Properties }}
    {{- $shouldIncludeAtomic := 0 -}}
    {{- $shouldIncludeMutex := 0 -}}
{{- range $i, $e := .Interface.Properties }}
	{{- if ( ueIsStdSimpleType . ) }}
	{{- $shouldIncludeAtomic = 1}}
	{{- else}}
	{{- $shouldIncludeMutex = 1}}
	{{- end}}
{{- end}}
{{- if (eq $shouldIncludeAtomic  1) }}
#include <atomic>
{{- end}}
{{- if (eq $shouldIncludeMutex 1) }}
#include "HAL/CriticalSection.h"
{{- end}}

/**
   \brief data structure to hold the last sent property values
*/
struct {{$Iface}}PropertiesMsgBusData
{
{{- range $i, $e := .Interface.Properties }}
	{{- if ( ueIsStdSimpleType . ) }}
	std::atomic<{{ueReturn "" .}}> {{ueVar "" .}}{ {{- ueDefault "" . -}} };
	{{- else }}
	FCriticalSection {{ueVar "" .}}Mutex;
	{{ueReturn "" .}} {{ueVar "" .}}{ {{- ueDefault "" . -}} };
	{{- end }}
{{- end }}
};
{{- end }}
DEFINE_LOG_CATEGORY(Log{{$Iface}}MsgBusClient);
{{ if .Interface.Description }}
/**
   \brief {{.Interface.Description}}
*/
{{- end }}
{{$Class}}::{{$Class}}()
	: {{$abstractclass}}()
{{- if len .Interface.Properties }}
	, _SentData(MakePimpl<{{$Iface}}PropertiesMsgBusData>())
{{- end }}
{
	/* m_sink = std::make_shared<FOLinkSink>("{{$ifaceId}}"); */
}

{{$Class}}::~{{$Class}}() = default;

void {{$Class}}::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);

	Connect();
}

void {{$Class}}::Deinitialize()
{
	Disconnect();

	Super::Deinitialize();
}

void {{$Class}}::Connect()
{
	if (IsConnected())
	{
		return;
	}

	if ({{$Iface}}MsgBusEndpoint.IsValid() && !ServiceAddress.IsValid())
	{
		DiscoverService();
		return;
	}

	// clang-format off
	{{$Iface}}MsgBusEndpoint = FMessageEndpoint::Builder("ApiGear/{{$ModuleName}}/{{$IfaceName}}/Client")
		.Handling<F{{$Iface}}InitMessage>(this, &{{$Class}}::OnConnectionInit)
		.Handling<F{{$Iface}}ServiceDisconnectMessage>(this, &{{$Class}}::OnServiceClosedConnection)
{{- range $i, $e := .Interface.Signals }}
{{- if $i }}{{nl}}{{ end }}
		.Handling<F{{$Iface}}{{Camel .Name}}SignalMessage>(this, &{{$Class}}::On{{Camel .Name}})
{{- end }}
{{- range $i, $e := .Interface.Properties }}
{{- if $i }}{{nl}}{{ end }}
		.Handling<F{{$Iface}}{{Camel .Name}}ChangedMessage>(this, &{{$Class}}::On{{Camel .Name}}Changed)
{{- end }}
{{- range $i, $e := .Interface.Operations }}
{{- if not .Return.IsVoid }}
		.Handling<F{{$Iface}}{{Camel .Name}}ReplyMessage>(this, &{{$Class}}::On{{Camel .Name}}Reply)
{{- end }}
{{- end }}
		.Build();
	// clang-format on

	DiscoverService();
}

void {{$Class}}::Disconnect()
{
	if (!IsConnected())
	{
		return;
	}

	auto msg = new F{{$Iface}}ClientDisconnectMessage();

	if ({{$Iface}}MsgBusEndpoint.IsValid())
	{
		{{$Iface}}MsgBusEndpoint->Send<F{{$Iface}}ClientDisconnectMessage>(msg, EMessageFlags::Reliable,
			nullptr,
			TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
			FTimespan::Zero(),
			FDateTime::MaxValue());
	}

	{{$Iface}}MsgBusEndpoint.Reset();
	ServiceAddress.Invalidate();
	_ConnectionStatusChanged.Broadcast(false);
}

void {{$Class}}::DiscoverService()
{
	if ({{$Iface}}MsgBusEndpoint.IsValid())
	{
		{{$Iface}}MsgBusEndpoint->Publish<F{{$Iface}}DiscoveryMessage>(new F{{$Iface}}DiscoveryMessage());
	}
}

bool {{$Class}}::IsConnected() const
{
	return {{$Iface}}MsgBusEndpoint.IsValid() && ServiceAddress.IsValid();
}

void {{$Class}}::OnConnectionInit(const F{{$Iface}}InitMessage& InInitMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (!ServiceAddress.IsValid())
	{
		ServiceAddress = Context->GetSender();

{{- range $i, $e := .Interface.Properties }}
{{- if $i }}{{nl}}{{ end }}
		const bool b{{ueVar "" .}}Changed = InInitMessage.{{ueVar "" .}} != {{ueVar "" .}};
		if (b{{ueVar "" .}}Changed)
		{
			{{ueVar "" .}} = InInitMessage.{{ueVar "" .}};
			Execute__GetSignals(this)->On{{ Camel .Name }}Changed.Broadcast({{ueVar "" .}});
		}
{{- end }}

		_ConnectionStatusChanged.Broadcast(true);
	}
	else
	{
		UE_LOG(Log{{$Iface}}MsgBusClient, Error, TEXT("Got a second init message - should not happen"));
	}
}

void {{$Class}}::OnServiceClosedConnection(const F{{$Iface}}ServiceDisconnectMessage& /*InMessage*/, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		return;
	}

	ServiceAddress.Invalidate();
	_ConnectionStatusChanged.Broadcast(false);
}

{{- if len .Interface.Properties }}{{ nl }}{{ end }}
{{- range $i, $e := .Interface.Properties }}
{{- if $i }}{{nl}}{{ end }}
{{ueReturn "" .}} {{$Class}}::Get{{Camel .Name}}_Implementation() const
{
	return {{ueVar "" .}};
}

{{- if not .IsReadOnly }}{{nl}}
void {{$Class}}::Set{{Camel .Name}}_Implementation({{ueParam "In" .}})
{
	if (!IsConnected())
	{
		UE_LOG(Log{{$Iface}}MsgBusClient, Error, TEXT("Client has no connection to service."));
		return;
	}

	// only send change requests if the value changed -> reduce network load
	if (Get{{Camel .Name}}_Implementation() == {{ueVar "In" .}})
	{
		return;
	}

	// only send change requests if the value wasn't already sent -> reduce network load
{{- if not ( ueIsStdSimpleType . )}}
	{
		FScopeLock Lock(&(_SentData->{{ueVar "" .}}Mutex));
		if (_SentData->{{ueVar "" .}} == {{ueVar "In" .}})
		{
			return;
		}
	}
{{- else}}
	if (_SentData->{{ueVar "" .}} == {{ueVar "In" .}})
	{
		return;
	}
{{- end }}

	auto msg = new F{{$Iface}}Set{{Camel .Name}}RequestMessage();
	msg->{{ueVar "" .}} = {{ueVar "In" .}};

	if ({{$Iface}}MsgBusEndpoint.IsValid())
	{
		{{$Iface}}MsgBusEndpoint->Send<F{{$Iface}}Set{{Camel .Name}}RequestMessage>(msg, EMessageFlags::Reliable,
			nullptr,
			TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
			FTimespan::Zero(),
			FDateTime::MaxValue());
{{- if not ( ueIsStdSimpleType . ) }}
		FScopeLock Lock(&(_SentData->{{ueVar "" .}}Mutex));
{{- end }}
		_SentData->{{ueVar "" .}} = {{ueVar "In" .}};
	}
}
{{- end }}
{{- end }}

{{- if len .Interface.Operations }}{{ nl }}{{ end }}
{{- range $i, $e := .Interface.Operations }}
{{- if $i }}{{nl}}{{ end }}
{{- if .Description }}
/**
   \brief {{.Description}}
*/
{{- end }}
{{- $returnVal := (ueReturn "" .Return)}}
{{$returnVal}} {{$Class}}::{{Camel .Name}}_Implementation({{ueParams "In" .Params}})
{
	if (!IsConnected())
	{
		UE_LOG(Log{{$Iface}}MsgBusClient, Error, TEXT("Client has no connection to service."));
	{{- if .Return.IsVoid }}

		return;
	{{- else }}

		return {{ ueDefault "" .Return }};
	{{- end }}
	}

	auto msg = new F{{$Iface}}{{Camel .Name}}RequestMessage();
	msg->RepsonseId = FGuid::NewGuid();
{{- range $i, $e := .Params }}
	msg->{{ueVar "" . }} = {{ueVar "In" . }};
{{- end }}

	if ({{$Iface}}MsgBusEndpoint.IsValid())
	{
	{{- if not .Return.IsVoid }}
		TPromise<{{$returnVal}}> Promise;
		StorePromise(msg->RepsonseId, Promise);
	{{- end }}

		{{$Iface}}MsgBusEndpoint->Send<F{{$Iface}}{{Camel .Name}}RequestMessage>(msg, EMessageFlags::Reliable,
			nullptr,
			TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
			FTimespan::Zero(),
			FDateTime::MaxValue());

	{{- if .Return.IsVoid }}

		return;
	{{- else }}

		return Promise.GetFuture().Get();
	{{- end }}
	}

{{- if .Return.IsVoid }}

	return;
{{- else }}

	return {{ ueDefault "" .Return }};
{{- end }}
}
{{- if not .Return.IsVoid }}

void {{$Class}}::On{{Camel .Name}}Reply(const F{{$Iface}}{{Camel .Name}}ReplyMessage& In{{Camel .Name}}ReplyMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	FulfillPromise(In{{Camel .Name}}ReplyMessage.RepsonseId, In{{Camel .Name}}ReplyMessage.Result);
}
{{- end }}
{{- end }}

{{- if len .Interface.Signals }}{{ nl }}{{ end }}
{{- range $i, $e := .Interface.Signals }}
{{- if $i }}{{nl}}{{ end }}
void {{$Class}}::On{{Camel .Name}}(const F{{$DisplayName}}{{Camel .Name}}SignalMessage& In{{Camel .Name}}Message, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(Log{{$Iface}}MsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

{{- $sigName := Camel .Name}}

	Execute__GetSignals(this)->On{{Camel .Name}}Signal.Broadcast(
{{- range $i, $e := .Params -}}
	{{ if $i }}, {{end}}In{{$sigName}}Message.{{ueVar "" .}}
{{- end -}}
	);
	return;
}
{{- end }}
{{- if len .Interface.Properties }}{{ nl }}{{ end }}
{{- range $i, $e := .Interface.Properties }}
{{- if $i }}{{nl}}{{ end }}
void {{$Class}}::On{{Camel .Name}}Changed(const F{{$DisplayName}}{{Camel .Name}}ChangedMessage& {{ueVar "In" .}}Message, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(Log{{$Iface}}MsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	const bool b{{ueVar "" .}}Changed = {{ueVar "In" .}}Message.{{ueVar "" .}} != {{ueVar "" .}};
	if (b{{ueVar "" .}}Changed)
	{
		{{ueVar "" .}} = {{ueVar "In" .}}Message.{{ueVar "" .}};
		Execute__GetSignals(this)->On{{Camel .Name}}Changed.Broadcast({{ueVar "" .}});
	}
}
{{- end }}

{{- if len .Interface.Operations }}

template <typename ResultType>
bool U{{$Iface}}MsgBusClient::StorePromise(const FGuid& Id, TPromise<ResultType>& Promise)
{
	FScopeLock Lock(&ReplyPromisesMapCS);
	return ReplyPromisesMap.Add(Id, &Promise) != nullptr;
}

template <typename ResultType>
bool U{{$Iface}}MsgBusClient::FulfillPromise(const FGuid& Id, const ResultType& Value)
{
	TPromise<ResultType>* PromisePtr = nullptr;

	{
		FScopeLock Lock(&ReplyPromisesMapCS);
		if (auto** Found = ReplyPromisesMap.Find(Id))
		{
			PromisePtr = static_cast<TPromise<ResultType>*>(*Found);
			ReplyPromisesMap.Remove(Id);
		}
	}

	if (PromisePtr)
	{
		PromisePtr->SetValue(Value);
		return true;
	}
	return false;
}
{{- $retTypes := getEmptyStringList}}
{{- range .Interface.Operations }}
{{- if not .Return.IsVoid }}
{{- $retType :=  ueReturn "" .Return }}
{{- $retTypes = (appendList $retTypes $retType) }}
{{- end }}
{{- end }}
{{- $retTypes = unique $retTypes }}
{{- if len $retTypes }}{{- nl }}{{- end }}
{{- range $retTypes }}
template bool U{{$Iface}}MsgBusClient::StorePromise<{{ .}}>(const FGuid& Id, TPromise<{{ .}}>& Promise);
template bool U{{$Iface}}MsgBusClient::FulfillPromise<{{ .}}>(const FGuid& Id, const {{ .}}& Value);
{{- end }}
{{- end }}
