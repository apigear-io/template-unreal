{{- /* Copyright Epic Games, Inc. All Rights Reserved */ -}}
/**{{ template "copyright" }}*/
{{- $ModuleName := Camel .Module.Name}}
{{- $IfaceName := Camel .Interface.Name }}
{{- $Category := printf "ApiGear|%s|%s" $ModuleName $IfaceName }}
{{- $DisplayName := printf "%s%s" $ModuleName $IfaceName }}
{{- $Class := printf "U%sOLinkClient" $DisplayName}}
{{- $abstractclass := printf "UAbstract%s%s" (Camel .Module.Name) (Camel .Interface.Name) }}
{{- $Iface := printf "%s%s" $ModuleName $IfaceName }}
{{- $ifaceId := printf "%s.%s" .Module.Name .Interface.Name}}

////////////////////////////////
// WARNING AUTOGENERATED
// DO NOT MODIFY
///////////////////////////////

#include "{{$ModuleName}}/Generated/OLink/{{$Iface}}OLinkClient.h"
#include "{{$ModuleName}}/Generated/Core/{{$ModuleName}}PropertiesData.h"
#include "ApiGearSettings.h"
#include "ApiGearOLink.h"
#include "Async/Async.h"
#include "{{$ModuleName}}/Generated/api/{{$ModuleName}}.json.adapter.h"
{{- range .Module.Imports }}
#include "{{Camel .Name}}/Generated/api/{{Camel .Name}}.json.adapter.h"
{{- end }}
#include "OLinkClientConnection.h"
#include "OLinkSink.h"
#include "Engine/Engine.h"
#include "ApiGear/Public/ApiGearConnectionsStore.h"
#include "Misc/DateTime.h"
#include "{{$ModuleName}}Settings.h"
THIRD_PARTY_INCLUDES_START
#include "olink/clientnode.h"
#include "olink/iobjectsink.h"
THIRD_PARTY_INCLUDES_END

DEFINE_LOG_CATEGORY(Log{{$Iface}}OLinkClient);
{{ if .Interface.Description }}
/**
   \brief {{.Interface.Description}}
*/
{{- end }}
{{$Class}}::{{$Class}}()
	: {{$abstractclass}}()
{{- if len .Interface.Properties }}
	, _SentData(MakePimpl<{{$Iface}}PropertiesData>())
{{- end }}
{
	m_sink = std::make_shared<FOLinkSink>("{{$ifaceId}}");
}

{{$Class}}::{{$Class}}(FVTableHelper& Helper)
	: Super(Helper)
{
}
{{$Class}}::~{{$Class}}() = default;

void {{$Class}}::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);

	m_sink->setOnInitCallback([this]()
		{
		_SubscriptionStatusChanged.Broadcast(true);
		_SubscriptionStatusChangedBP.Broadcast(true);
	});
	m_sink->setOnReleaseCallback([this]()
		{
		_SubscriptionStatusChanged.Broadcast(false);
		_SubscriptionStatusChangedBP.Broadcast(false);
	});

	FOLinkSink::FPropertyChangedFunc PropertyChangedFunc = [this](const nlohmann::json& props)
	{
		this->applyState(props);
	};
	m_sink->setOnPropertyChangedCallback(PropertyChangedFunc);

	FOLinkSink::FSignalEmittedFunc SignalEmittedFunc = [this](const std::string& signalName, const nlohmann::json& args)
	{
		this->emitSignal(signalName, args);
	};
	m_sink->setOnSignalEmittedCallback(SignalEmittedFunc);

	check(GEngine);
	U{{$ModuleName}}Settings* settings = GetMutableDefault<U{{$ModuleName}}Settings>();

	UApiGearConnectionsStore* AGCM = GEngine->GetEngineSubsystem<UApiGearConnectionsStore>();

	TScriptInterface<IApiGearConnection> OLinkConnection = AGCM->GetConnection(settings->OLinkConnectionIdentifier);

	if (!OLinkConnection.GetInterface())
	{
		return;
	}
	UseConnection(OLinkConnection);
	OLinkConnection->Connect();
}

void {{$Class}}::Deinitialize()
{
	// tell the sink that we are gone and should not try to be invoked
	m_sink->resetOnPropertyChangedCallback();
	m_sink->resetOnSignalEmittedCallback();
	m_sink->resetOnInitCallback();
	m_sink->resetOnReleaseCallback();

	if (Connection.GetObject())
	{
		UOLinkClientConnection* UnrealOLinkConnection = Cast<UOLinkClientConnection>(Connection.GetObject());
		UnrealOLinkConnection->unlinkObjectSource(m_sink->olinkObjectName());
		UnrealOLinkConnection->node()->registry().removeSink(m_sink->olinkObjectName());
	}

	Super::Deinitialize();
}

void {{$Class}}::UseConnection(TScriptInterface<IApiGearConnection> InConnection)
{
	if (!InConnection.GetInterface())
	{
		UE_LOG(Log{{$Iface}}OLinkClient, Error, TEXT("The olink connection for the %s client does not implement the connection interface."), UTF8_TO_TCHAR(m_sink->olinkObjectName().c_str()));
		return;
	}

	// only accept connections of type olink
	checkf(InConnection->GetConnectionProtocolIdentifier() == ApiGearOLinkProtocolIdentifier, TEXT("Cannot use connection - must be of type olink"));

	UOLinkClientConnection* UnrealOLinkConnection = nullptr;
	// remove old connection
	if (Connection.GetObject())
	{
		UnrealOLinkConnection = Cast<UOLinkClientConnection>(Connection.GetObject());
		UnrealOLinkConnection->unlinkObjectSource(m_sink->olinkObjectName());
		UnrealOLinkConnection->node()->registry().removeSink(m_sink->olinkObjectName());
		UnrealOLinkConnection = nullptr;
	}

	// set up new connection
	UnrealOLinkConnection = Cast<UOLinkClientConnection>(InConnection.GetObject());
	UnrealOLinkConnection->node()->registry().addSink(m_sink);
	UnrealOLinkConnection->linkObjectSource(m_sink->olinkObjectName());

	Connection = InConnection;
}

{{- if len .Interface.Properties }}{{ nl }}{{ end }}
{{- range $i, $e := .Interface.Properties }}
{{- if $i }}{{nl}}{{ end }}
{{ueReturn "" .}} {{$Class}}::Get{{Camel .Name}}() const
{
	return {{ueVar "" .}};
}

{{- if not .IsReadOnly }}{{nl}}
void {{$Class}}::Set{{Camel .Name}}({{ueParam "In" .}})
{
	TRACE_CPUPROFILER_EVENT_SCOPE_STR("ApiGear.{{$ModuleName}}.{{$IfaceName}}.OLink.Set{{Camel .Name}}");
	if (!m_sink->IsReady())
	{
		UE_LOG(Log{{$Iface}}OLinkClient, Error, TEXT("%s has no node. Probably no valid connection or service. Are the ApiGear {{ $ModuleName }} plugin settings correct? Service set up correctly?"), UTF8_TO_TCHAR(m_sink->olinkObjectName().c_str()));
		return;
	}

	// only send change requests if the value changed -> reduce network load
	if (Get{{Camel .Name}}() == {{ueVar "In" .}})
	{
		return;
	}

	// only send change requests if the value wasn't already sent -> reduce network load
{{- if not ( ueIsStdSimpleType . )}}
	if (_SentData->Get{{ueVar "" .}}() == {{ueVar "In" .}})
	{
		return;
	}
{{- else}}
	if (_SentData->{{ueVar "" .}} == {{ueVar "In" .}})
	{
		return;
	}
{{- end }}
	static const auto memberId = ApiGear::ObjectLink::Name::createMemberId(m_sink->olinkObjectName(), "{{.Name}}");
	m_sink->GetNode()->setRemoteProperty(memberId, {{ueVar "In" .}});
{{- if not ( ueIsStdSimpleType . ) }}
	_SentData->Set{{ueVar "" .}}({{ueVar "In" .}});
{{- else }}
	_SentData->{{ueVar "" .}} = {{ueVar "In" .}};
{{- end }}
}
{{- end }}
{{- end }}
{{- if len .Interface.Operations }}{{ nl }}{{ end }}
{{- range $i, $e := .Interface.Operations }}
{{- if $i }}{{nl}}{{ end }}
{{- if .Description }}
/**
   \brief {{.Description}}
*/
{{- end }}
{{- $returnVal := (ueReturn "" .Return)}}
{{$returnVal}} {{$Class}}::{{Camel .Name}}({{ueParams "" .Params}})
{
	TRACE_CPUPROFILER_EVENT_SCOPE_STR("ApiGear.{{$ModuleName}}.{{$IfaceName}}.OLink.{{Camel .Name}}");
	{{- if .Return.IsVoid }}
	if (!m_sink->IsReady())
	{
		UE_LOG(Log{{$Iface}}OLinkClient, Error, TEXT("%s has no node. Probably no valid connection or service. Are the ApiGear {{ $ModuleName }} plugin settings correct? Service set up correctly?"), UTF8_TO_TCHAR(m_sink->olinkObjectName().c_str()));

		return;
	}
	ApiGear::ObjectLink::InvokeReplyFunc Get{{$IfaceName}}StateFunc = [this](ApiGear::ObjectLink::InvokeReplyArg arg) {};
	static const auto memberId = ApiGear::ObjectLink::Name::createMemberId(m_sink->olinkObjectName(), "{{.Name}}");
	m_sink->GetNode()->invokeRemote(memberId, { {{- ueVars "" .Params -}} }, Get{{$IfaceName}}StateFunc);
	{{- else }}
	return {{Camel .Name}}Async({{ueVars "" .Params}}).Get();
	{{- end }}
}
{{- if not .Return.IsVoid }}{{nl}}
{{- if .Description }}
/**
   \brief {{.Description}} - Async version
*/
{{- end }}
{{- $returnVal := (ueReturn "" .Return)}}
TFuture<{{$returnVal}}> {{$Class}}::{{Camel .Name}}Async({{ueParams "" .Params}})
{
	TRACE_CPUPROFILER_EVENT_SCOPE_STR("ApiGear.{{$ModuleName}}.{{$IfaceName}}.OLink.{{Camel .Name}}Async");
	if (!m_sink->IsReady())
	{
		UE_LOG(Log{{$Iface}}OLinkClient, Error, TEXT("%s has no node. Probably no valid connection or service. Are the ApiGear {{ $ModuleName }} plugin settings correct? Service set up correctly?"), UTF8_TO_TCHAR(m_sink->olinkObjectName().c_str()));

		TPromise<{{$returnVal}}> Promise;
		Promise.SetValue({{ ueDefault "" .Return }});
		return Promise.GetFuture();
	}

	TSharedRef<TPromise<{{$returnVal}}>> Promise = MakeShared<TPromise<{{$returnVal}}>>();

	static const auto memberId = ApiGear::ObjectLink::Name::createMemberId(m_sink->olinkObjectName(), "{{.Name}}");

	m_sink->GetNode()->invokeRemote(memberId, { {{- ueVars "" .Params -}} },
		[Promise](ApiGear::ObjectLink::InvokeReplyArg arg)
		{
		// check for actual field in j object and make sure the type matches our expectation
		if (!arg.value.is_null() && !arg.value.is_discarded(){{ " " }}
		{{- if .Return.IsArray -}}
			&& arg.value.is_array()
		{{- else if eq .Return.KindType "enum" -}}
			&& arg.value.is_number_integer()
		{{- else if .Return.IsPrimitive -}}
			{{- if eq .Return.Type "bool" -}}
			&& arg.value.is_boolean()
			{{- else if or (eq .Return.Type "int") (eq .Return.Type "int32") (eq .Return.Type "int64") -}}
			&& arg.value.is_number_integer()
			{{- else if or (eq .Return.Type "float") (eq .Return.Type "float32") (eq .Return.Type "float64") -}}
			&& arg.value.is_number()
			{{- else if eq .Return.Type "string" -}}
			&& arg.value.is_string()
			{{- end }}
		{{- else -}}
			&& arg.value.is_object()
		{{- end }})
		{
			Promise->SetValue(arg.value.get<{{$returnVal}}>());
		}
		else
		{
			UE_LOG(Log{{$Iface}}OLinkClient, Warning, TEXT("{{Camel .Name}}Async: invalid return value type or null -> returning default"));
			Promise->SetValue({{ ueDefault "" .Return }});
		}
	});

	return Promise->GetFuture();
}
{{- end }}
{{- end }}

bool {{$Class}}::_IsSubscribed() const
{
	return m_sink->IsReady();
}

void {{$Class}}::applyState(const nlohmann::json& fields)
{
	TRACE_CPUPROFILER_EVENT_SCOPE_STR("ApiGear.{{$ModuleName}}.{{$IfaceName}}.OLink.ApplyState");
{{- range $i, $e := .Interface.Properties }}
{{- if $i }}{{nl}}{{ end }}
	const bool b{{Camel .Name}}Changed = fields.contains("{{.Name}}") && ({{ueVar "" .}} != fields["{{.Name}}"].get<{{ueReturn "" .}}>());
	if (b{{Camel .Name}}Changed)
	{
		{{ueVar "" .}} = fields["{{.Name}}"].get<{{ueReturn "" .}}>();
		// reset sent data to the current state
		{{- if not ( ueIsStdSimpleType . )}}
		_SentData->Set{{ueVar "" .}}({{ueVar "" .}});
		{{- else}}
		_SentData->{{ueVar "" .}} = {{ueVar "" .}};
		{{- end }}
		_GetPublisher()->Broadcast{{Camel .Name}}Changed({{ueVar "" .}});
	}
{{- end }}
}

void {{$Class}}::emitSignal(const std::string& signalName, const nlohmann::json& args)
{
	TRACE_CPUPROFILER_EVENT_SCOPE_STR("ApiGear.{{$ModuleName}}.{{$IfaceName}}.OLink.EmitSignal");
{{- range $i, $e := .Interface.Signals }}
{{- if $i }}{{nl}}{{ end }}
	if (signalName == "{{.Name}}")
	{
		{{- if gt (len .Params) 0 }}
		// check for correct array size
		if (!args.is_array() || args.size() < {{len .Params}})
		{
			UE_LOG(Log{{$Iface}}OLinkClient, Error, TEXT("Signal {{.Name}}: invalid args array (expected {{len .Params}} elements)"));
			return;
		}
		{{- end }}
		{{- range $idx, $elem := .Params }}
		// make sure the type matches our expectation
		if (args[{{$idx}}].is_null(){{ " " }}
		{{- if .IsArray -}}
			|| !args[{{$idx}}].is_array()
		{{- else if eq .KindType "enum" -}}
			|| !args[{{$idx}}].is_number_integer()
		{{- else if .IsPrimitive -}}
			{{- if eq .Type "bool" -}}
			|| !args[{{$idx}}].is_boolean()
			{{- else if or (eq .Type "int") (eq .Type "int32") (eq .Type "int64") -}}
			|| !args[{{$idx}}].is_number_integer()
			{{- else if or (eq .Type "float") (eq .Type "float32") (eq .Type "float64") -}}
			|| !args[{{$idx}}].is_number()
			{{- else if eq .Type "string" -}}
			|| !args[{{$idx}}].is_string()
			{{- end }}
		{{- else -}}
			|| !args[{{$idx}}].is_object()
		{{- end }})
		{
			UE_LOG(Log{{$Iface}}OLinkClient, Error, TEXT("Signal {{.Name}}: invalid type for parameter {{$idx}}"));
			return;
		}
		{{ueParam "out" .}} = args[{{$idx}}].get<{{ueReturn "" .}}>();
		{{- end }}
		_GetPublisher()->Broadcast{{Camel .Name}}Signal({{ueVars "out" .Params}});
		return;
	}
{{- end }}
}
